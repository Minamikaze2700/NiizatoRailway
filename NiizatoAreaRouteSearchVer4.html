
<!DOCTYPE html>

<html lang="ja">
<head>
<meta charset="utf-8"/>
<title>新里地方 乗換案内</title>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<style>
:root{
  --bg:#f1f5f9;
  --card:#fff;
  --muted:#667085;
  --radius:12px;
  --gutter:34px;
  --dotMajor:16px;
  --dotMinor:12px;
  --lineWMajor:5px;
  --lineWMinor:5px;
  --font-sans:"Hiragino Kaku Gothic ProN","Meiryo",system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans JP",sans-serif;
}
html,body{height:100%;margin:0;font-family:var(--font-sans);background:var(--bg);color:#0b1324}
.wrap{max-width:980px;margin:28px auto;padding:20px}
h1{margin:0 0 12px;font-size:20px}
.card{background:var(--card);border-radius:var(--radius);padding:16px;box-shadow:0 8px 24px rgba(2,6,23,0.07);margin:12px 0px}
.row{display:flex;gap:12px;align-items:flex-start;flex-direction:column}
.col{display:flex;flex-direction:column;gap:6px;position:relative;align-items:flex-start}
select,button{font-size:14px;padding:8px 10px;border-radius:4px;border:1px solid #d1d5db;background:#fff}
label{font-size:13px;color:var(--muted)}
button.primary{cursor:pointer;background:#0b5fff;color:#fff;border:none}
.resultHeader{display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
.resultHeader .meta{display:flex;gap:18px;color:#111}

.tabs{display:flex;gap:8px;margin-bottom:8px}
.tabBtn{padding:6px 12px;border-radius:6px;border:1px solid #ccc;background:#eee;cursor:pointer}
.tabBtn.active{background:#0b5fff;color:#fff;border-color:#0b5fff}

/* 路線図レイアウト */
.routeLine{display:flex;flex-direction:column;gap:10px;margin-top:4px}
.rowStation{display:grid;grid-template-columns:var(--gutter) 1fr;align-items:start;column-gap:10px;position:relative;}
.railCol{display:flex;flex-direction:column;align-items:center;position:relative;width:var(--gutter);box-sizing:border-box;}
.railDot{border-radius:50%;width:var(--dotMajor);height:var(--dotMajor);z-index:3;border:2px solid #fff;position:absolute;left:50%;top:0;transform:translateX(-50%);box-sizing:content-box;}
.rowBetween .railDot{width:var(--dotMinor);height:var(--dotMinor);border:2px solid #fff;position:absolute;left:50%;top:0;transform:translateX(-50%);z-index:2;}
.railLineMajor{width:var(--lineWMajor);border-radius:2px;position:absolute;left:50%;transform:translateX(-50%);z-index:1;top:100px;height:0;background:#999;}

.railLineMinor{width:var(--lineWMinor);border-radius:1px;position:absolute;left:50%;transform:translateX(-50%);z-index:1;top:100px;height:0;background:#999;}
/* バス用の白いオーバーレイ（線の中央に1pxの白線を乗せる。ドットの上は空けるため、JSで高さを調整します） */
.busOverlay{
  position:absolute;
  left:50%;
  transform:translateX(-50%);
  width:1px;
  background:#fff;
  z-index:2;
  pointer-events:none;
}

.stationText{display:flex;flex-direction:column;align-items:flex-start;justify-content:flex-start}
.stationName{font-weight:700;font-size:16px;line-height:1.25;margin:0}
.lineBadge{display:inline-block;color:#fff;font-size:13.5px;line-height:1;padding:2px 6px;border-radius:6px;margin-top:6px;white-space:nowrap;margin-right:6px}
.toggleWrap{margin-top:6px}
.toggleBtn{cursor:pointer;padding:4px 8px;font-size:12px}
.rowBetween{display:grid;grid-template-columns:var(--gutter) 1fr;column-gap:10px;align-items:start;height:auto;padding-top:12px;}
.rowBetween .stationText{display:flex;align-items:flex-start;padding-top:0;}
.minorName{font-size:14px;font-weight:400;margin:0;position:relative;top:-4px;}
.condMinorName{font-size:14px;font-weight:400;margin:0;position:relative;top:-4px;color:#333;}
.rowBetween .railLineMinor{height:48px;}
.betweenList{ display:none; }
.spacer4{height:4px}
.spacer6{height:6px}
.viaList{display:flex;flex-direction:column;gap:6px;margin:6px 0;align-items:flex-start}
.viaRow{display:flex;align-items:center;gap:6px;justify-content:flex-start}
.viaRow button{font-size:12px;padding:4px 6px}
.CompatibleRoutes{height: 145px;overflow: auto;background:#fff}
.CompatibleRoutes p{margin:0em 12px}
</style>

<style>
.between-count{
  font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", "Hiragino Kaku Gothic ProN", "メイリオ", sans-serif;
  color: #111;
  background: rgba(255,255,255,0.9);
  border: 1px solid rgba(0,0,0,0.12);
  padding: 2px 6px;
  font-weight: 600;
  font-size: 12px;
  line-height: 1;
  border-radius: 6px;
  box-shadow: 0 1px 2px rgba(0,0,0,0.08);
  z-index: 9999;
}
</style>

<style>
.between-count{
  font-family: "Noto Sans JP", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
  color: #fff;
  background: #f5a623;
  border-radius: 999px;
  padding: 2px 8px;
  font-weight: 700;
  font-size: 12px;
  line-height: 1;
  box-shadow: 0 1px 2px rgba(0,0,0,0.08);
  z-index: 9999;
  display: inline-block;
}
</style>

<style>
.between-count{
  font-family: "Noto Sans JP", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
  color: #fff;
  background: #f5a623;
  border-radius: 999px;
  padding: 1px 6px;
  font-weight: 700;
  font-size: 11px;
  line-height: 1;
  box-shadow: 0 1px 2px rgba(0,0,0,0.06);
  z-index: 9999;
  display: inline-block;
  border: 1px solid #fff;
}
</style>
</head>
<body>
<div class="wrap">
<h2>新里地方 乗換案内</h2>
<h1>対応路線</h1>
<div class="CompatibleRoutes">
<p>新里鉄道：全線</p>
<p>豊野鉄道：全線</p>
<p>桜川電気鉄道：全線</p>
<p>床川急行電鉄：全線</p>
<p>浪川急行電鉄：全線</p>
<p>今橋鉄道：豊海線 全線　成津線 全線</p>
<p>小金鉄道：全線</p>
<p>東雲鉄道：全線</p>
<p>大桑鉄道：本線 桑畑～内原　豊川線 全線　岩田線 全線</p>
<p>東橋鉄道：全線</p>
<p>ただいま新駅設置のため乗換案内に出づらくなっています。</p>
<p>坂津ポートライナー：全線</p>
<p>西桜開発鉄道：萩崎線 岩川崎～東橋</p>
<p>笠原電気鉄道：全線</p>
</div>
<p>バグを発見したら<a href="mailto:minamikaze2700@gmail.com">こちら</a>までご連絡ください。</p>
<h1>機能追加予定</h1>
<div class="CompatibleRoutes">
<p>・迂回ルート検索</p>
<p>・駅情報の表示</p>
<p>・ナンバリング表示</p>
<p>・定期区間設定</p>
<p>・フリーきっぷなどお得なきっぷ対応</p>
<p>・運賃が安いルートの追加</p>
<p>・列車時刻を考慮した乗換案内</p>
</div>
<div class="card">
<div id="stationSelector">
<div class="row">
<div class="col">
<label>発駅</label>
<div style="display:flex;gap:6px">
<select class="lineSelect" id="fromLine"></select>
<select class="stationSelect" id="fromStation"></select>
</div>
</div>
<div class="col">
<label>経由地</label>
<div class="viaList" id="viaList"></div>
<button class="primary" id="addViaBtn">経由地を追加</button>
</div>
<div class="col">
<label>着駅</label>
<div style="display:flex;gap:6px">
<select class="lineSelect" id="toLine"></select>
<select class="stationSelect" id="toStation"></select>
</div>
</div>
<div style="display:flex;align-items:flex-end;">
<button class="primary" id="searchBtn">検索</button>
</div>
</div>
</div>
</div>
<div class="tabs" id="resultTabs" style="display:none">
<button class="tabBtn active" data-target="shortest">距離が短いルート</button>
<button class="tabBtn" data-target="fewest">乗換が少ないルート</button>
</div>
<div id="resultArea">
<div id="result-shortest"></div>
<div id="result-fewest" style="display:none"></div>
</div>
</div>
<script>
// ---------- 表示用駅名処理 ----------
function displayStationName(name){
  return (name || '').replace(/\(今橋鉄道\)|\(床川急行電鉄\)|\(新里鉄道\)|\(桜川電鉄\)/g, "");
}

// ==== 駅・路線データ ====
const stationLines = {
 "今橋鉄道成津線":["今橋","新今橋","土川","小弥又","大弥又","今橋学園前","久末","大町","成津","東成津","津塚","牛ヶ瀬","松橋","合浜","綿部","陣中原","萱海","弦川","二番街","高越","築田市","南築田","榎仏子","高座","口松","津垣","大道寺"],
 "今橋鉄道豊海線":["成津","北成津","原葉","徳橋","発樫","豊海","虹松","甲部","夕陽ヶ浜","艶華","富士町","園木"],
 "今橋鉄道最黒線":["豊海","東豊海","牛見","三九十九","咲田口","深原","南八幡","榛葉","山中","大岡山","藤宮","継立","緑川","旭原(今橋鉄道)","西国浜","最黒","東栗山","秋岡","宮川","寺島"],
 "笠原電気鉄道笠原本線":["浜笠原","水都臨海公園","北笠原","笠原","南笠原","久居","高城山","高城","東高城","木浦","久和野","牧原","狩川","城戸","坂井田","上須坂","蓬原","古川","津村","東津村"],
 "小金鉄道東雲線":["豊海","宮内","姫木","東小金","小金","西小金","杖原","東福寺","西行","出谷","古宮","外河原","坂下","田越","掘割","妙花","西本町","新東雲","東雲"],
 "小金鉄道小金線":["松橋","元町本通","赤原","殿内","小金","小金本郷","栄浦","尾田","五条","積岡","襟ヶ谷","大和ヶ丘","福住","白羽","東郷","岩内","南徳倉","徳倉"],
 "坂津電鉄坂津本線":["坂津港","港通","坂電坂津","大井野","中天神町","飯倉町","酒何町","能地","初川","春原","岩川崎"],
 "坂津電鉄豊町線":["豊町","削野","勝垰","重石町","東坂津","港通"],
 "坂津ポートライナー":["横宿","北横宿","総合運動場","郡元","鈴里","港通","坂津港"],
 "桜川電気鉄道桜州環状線":["木ノ葉台","八軒町","川渡","西中野","中野","東中野","桜台","福原","桜鉄久我原","桜鉄浪原","彩山川","似島","中洲","糸島","南糸島","野瀬","新浜","海岸通り","桜町","東片野","東新地","新地","西新地","室町","永楽町","加納","日野原","南春田","春田","北春田"],
 "桜川電気鉄道空港線":["桜川","公園東口","桜川公園北口","御厨","南深江","北深江","桜鉄浪原","東浪原","喜多瀬浜","葵台","汐見台","月野原","高瀬","結原","りんくう桜川","桜川国際空港(桜川電鉄)"],
 "桜川電気鉄道彩山線":["喜多瀬浜","喜多瀬","久我山","桜鉄彩山口"],
 "桜川電気鉄道中野線":["中野","南中野","大里","栄町","北桜川","桜川","南桜川","東豊野","すすき野","永田","平川","片野","東片野","りんかい公園","新地港"],
 "東雲鉄道内原線":["作平","北作平","扇原","大八木","出町","さくら大谷","小野","笠岡","中の内","萱尾","内原"],
 "東雲鉄道東雲本線":["大道寺","松木","南綾山","桜陽台","出庭","小木橋","布井","井畔","北條","佐山","福寺","旭口","増林","田井島","飯野","鵜木","東雲","北東雲","大岡浜","上宿","下宿","驫木","朝治","尾野見","前芝","後芝","上代","東津村","古川大橋","下甲","谷山","秋郷","作平"],
 "東雲鉄道東橋線":["作平","南望町","陣内","砂郷","前岡","",""],
 "菅谷高速鉄道東西線":["栃戸橋","新園木","西園木","克己ヶ丘","柴岡","新柴岡","亀浜","湊塚公園","三島崎","三筋大宮","襟ヶ谷","時雨町","珠洲","栗浜","大野城","郡津六番台","東菅谷","菅谷","菖蒲中央"],
 "西桜開発鉄道萩崎線":["岩川崎","南春原","元島","西荻","神庄","萩川","守辻","南風野","東橋","浪羽町","佐太天神","木曽方","生馬","森口","西里万騎ヶ原","西里医科大前","徳倉","大千早","雁巣","砥部市","孤見崎","うらら野","菖蒲緑ヶ丘","桐ヶ谷","菖蒲中央"],
 "千鳥鉄道内原線":["鈴代","新白鳥","白鳥","内原"],
 "千鳥鉄道白洲線":["鈴代","三葉公園","尉鶲","燕ヶ丘","銅台","観音通","白魚","鷺濱","縞鯵","白洲"],
 "千鳥鉄道千鳥線":["鈴代","柿崎","鴫山","帝国橋","飛魚","鳩音台","鰯塚","舟林","球河","樫ヶ谷","連雀","上橋","東上橋","千鳥ヶ浜"],
 "千鳥鉄道水都線":["観音通","斑鳩","守川神宮","雁金台","水都"],
 "槻平急行電鉄槻平本線":["大弥又","北稜","桃野","秦戸","鶴田","太田井","池戸","島井","七道","布田","築田医大前","下城","水木","飛江田","中浜町","大道寺","真華","白福","有津","馬原川","緑地中央","玉岡","西玉岡","浦江","鶴原","岩藤公園","三厨","亘谷","東川","狐山新町","秋部","東槻平","槻平","新槻平","矢附","塩塚","槻平公園","内鴨川","寺内","鞍部","村橋"],
 "槻平急行電鉄宮苗線":["槻平","京町","槻平球場前","北岡","忠津","新森内","青野","春木湖","宮苗"],
 "床川急行電鉄床川港線":["床川市","東床川","畠山","真沢","みなと西町","床川港"],
 "床川急行電鉄本線":["新地","南新地","熊井","富町","北濱石","濱石","尼田","玉田","倉上","秋岡","今川市","石津台","北吉田","牧町","吉田市","大河","井嶋田","井幡","床川北口","床北公園前","磐谷","又木","床川市","旭原(床川急行電鉄)","山木","宮田野","戸倉","外川崎","東学園都市","床川学園都市"],
 "豊野鉄道天津川線":["天津川温泉","坂川","北桑畑","桑畑","常盤台","天津川","南天津","広野","野川","東羽草","羽草","","","東小動","小動"],
 "豊野鉄道芝原線(仮称)":["桑畑","新桑畑","横山町","東天津","天津中原","北中原","大塚台","観音寺","香春町","芝原","","","","","滝原","南萩川","萩川","平沢町","鶴原","若葉台","内原城址公園","南内原","内原","北原台","斑鳩宮前","守川","水都","西水都","瀬戸川","笠原","西笠原","浅端","出見川","関戸","櫛田","柳井原","柳井港"],
 "豊野鉄道豊野線":["糸島","西糸島","平田","文京町","東桜川","桜川","豊野月見台","豊野","西豊野","白州川","春田","桜峠","桑畑"],
 "豊野鉄道中原線(仮称)":["天津中原","南中原","旭町","川端","","蟹沢","追分","","羽草"],
 "豊野鉄道韮郷線":["芝原","都川","","","","栄","韮郷公園前","韮郷"],
 "豊野鉄道緑川線":["豊野","新豊野","日野","加納","西永楽","天津山下","白金町","増枝","豊栄町","柿木橋","白梨町","渡河","椚原","大岡","北緑川","緑川","壇ノ原","国府","海田","南海田","祗園橋","紋花町","朱鷺橋","久知川","橘木","榛原","南榛原","北戸倉","戸倉","戸倉本町","久志","北天神","天神台","東瀬尾","瀬尾"],
 "浪川急行電鉄善崎線":["赤塚台","御簾谷","下大原","赤塚口","大野部","黒髪","沼の上","瀬尾","沼の下","烏田","大苫","上菊池","権手","床川学園都市"],
 "浪川急行電鉄浪川本線":["床川市","床川南","久屋","知野場","何原","土根","中床川口","床川口","押倉","尾奈居","賀根","江小野","赤塚台","赤塚新町","二十四日","古語町","北久野","野々垣","油家","大保","筈山","妹子町","下妹子","風見井","山経","河原橋","東河原橋","千々羽","枝皆","湖多田","摺名","大白石","東道学院前","紫芝","反川","北久地","南久地","蛇場","上田興","師事野","夢の台","緋野柴山","緋野市","南緋野","道末","二重寺","蘭ヶ峰","芝の原","北大虎","大虎","翡翠橋","浪川墾田町","浪川"],
 "新里鉄道燠野線":["湯の浜","新里大学前","綾原","福来","燠野","湯川","温泉口","燠野温泉"],
 "新里鉄道彩山線":["彩山","彩山口","新里国際スキー場","鷹見台","久我原","浪原","深江","三栗谷","桜川公園","桜川"],
 "新里鉄道鶴宮線":["鶴宮","南鶴宮","あずさ台","橘町","燠野山口","白枝","燠野","紅葉台","桐山","湊川","彩山親水公園","彩山","蓮華寺","星宮","田ノ原"],
 "新里鉄道新里線":["新里","南新里","田ノ原","北玖川","玖川","中野原"],
 "新里鉄道湯の浜線": ["豊町","東豊町","清水浜","安田町","南栃原","栃原","宇城","須川","御浜埼公園","御浜","伊坂","垳下","北浜","西新里","新里","河岸","新里海浜公園","湯の浜海岸","湯の浜","七浦","那珂町","宇多野","伊奈崎","鶴宮神社","鶴宮","北鶴宮","鬼越峠","片牧町","虹川","新的場","神道山口","原津","奥沢高原","京新峡","流沢温泉","流沢温泉口","白木稲荷","籾井","猫崎海岸","百合ヶ丘公園","北河都","河都","南河都","恋野宮","紅原台","外神","大三浜","千種園","白砂","余田","りんくう桜川","桜川国際空港(新里鉄道)"],
 "徒歩乗換": ["浪原","桜鉄浪原","桜川国際空港(新里鉄道)","桜川国際空港(桜川電鉄)"],
};
const lineColors = {
  "新里鉄道湯の浜線":"#07b5f7",
  "新里鉄道燠野線":"#fd5062",
  "新里鉄道鶴宮線":"#feac2c",
  "新里鉄道新里線":"#0cab5e",
  "新里鉄道彩山線":"#7dca22",
  "大桑鉄道本線":"#00c6d6",
  "大桑鉄道豊川線":"#ff2e2e",
  "大桑鉄道岩田線":"#9211b6",
  "桜川電気鉄道彩山線":"#20b07b",
  "桜川電気鉄道中野線":"#e296f1",
  "桜川電気鉄道空港線":"#2dbbe5",
  "桜川電気鉄道桜州環状線":"#f18b23",
  "豊野鉄道豊野線":"#239d54",
  "豊野鉄道坂川線":"#fdc01f",
  "豊野鉄道緑川線":"#2478ff",
  "坂津電鉄坂津本線":"#0044cc",
  "坂津電鉄豊町線":"#0044cc",
  "東橋鉄道東橋本線":"#00cc99",
  "東橋鉄道横宿線":"#0099cc",
  "坂津ポートライナー":"#33ccff",
  "今橋鉄道豊海線":"#1f1fff",
  "今橋鉄道最黒線":"#1f1fff",
  "今橋鉄道成津線":"#ff0000",
  "小金鉄道小金線":"#ebd000",
  "小金鉄道東雲線":"#00ccc6",
  "西桜開発鉄道萩崎線":"#0c46c0",
  "東雲鉄道東雲本線":"#008002",
  "東雲鉄道内原線":"#ffa40f",
  "東雲鉄道東橋線":"#a51aff",
  "床川急行電鉄本線":"#ff6100",
  "床川急行電鉄床川港線":"#ff6100",
  "千鳥鉄道内原線":"#e27132",
  "千鳥鉄道千鳥線":"#2930bc",
  "千鳥鉄道白洲線":"#1dc95f",
  "千鳥鉄道水都線":"#cc0f0f",
  "菅谷高速鉄道東西線":"#0063e0",
  "浪川急行電鉄浪川本線":"#51a6cd",
  "浪川急行電鉄善崎線":"#51a6cd",
  "笠原電気鉄道笠原本線":"#65da44",
  "槻平急行電鉄槻平本線":"#ff05ee",
  "槻平急行電鉄宮苗線":"#0000ff"
};

const railwayCompanyList = [
  "新里鉄道","大桑鉄道","桜川電気鉄道","豊野鉄道","今橋鉄道","東雲鉄道",
  "東橋鉄道","床川急行電鉄","坂津電鉄","西桜開発鉄道","菅谷高速鉄道","千鳥鉄道","小金鉄道","坂津ポートライナー","浪川急行電鉄","笠原電気鉄道","槻平急行電鉄"
];
const busCompanyList = [""];


const rawGraph={
"豊町":{"東豊町":1.2},
"東豊町":{"清水浜":1.4},
"清水浜":{"安田町":1.9},
"安田町":{"南栃原":2.2},
"南栃原":{"栃原":0.9},
"栃原":{"宇城":2.2},
"宇城":{"須川":2.1},
"須川":{"御浜埼公園":1.9},
"御浜埼公園":{"御浜":0.6},
"御浜":{"伊坂":2.5},
"伊坂":{"垳下":2.6},
"垳下":{"北浜":2.3},
"北浜":{"西新里":1.4},
"西新里":{"新里":1.7},
"新里":{"河岸":0.9,"南新里":2.5},
"河岸":{"新里海浜公園":1.7},
"新里海浜公園":{"湯の浜海岸":2.3},
"湯の浜海岸":{"湯の浜":1.5},
"湯の浜":{"七浦":2.5,"新里大学前":0.8},
"七浦":{"那珂町":1.6},
"那珂町":{"宇多野":2.2},
"宇多野":{"伊奈崎":1.8},
"伊奈崎":{"鶴宮神社":1.5},
"鶴宮神社":{"鶴宮":1.2},
"鶴宮":{"北鶴宮":1.1,"南鶴宮":1.7},
"新里大学前":{"綾原":0.7},
"綾原":{"福来":1.2},
"福来":{"燠野":1.4},
"燠野":{"湯川":2.6,"紅葉台":1.1},
"湯川":{"温泉口":1.6},
"温泉口":{"燠野温泉":1.9},
"南鶴宮":{"あずさ台":1.4},
"あずさ台":{"橘町":1.8},
"橘町":{"燠野山口":1.1},
"燠野山口":{"白枝":1.2},
"白枝":{"燠野":1.1},
"紅葉台":{"桐山":0.8},
"桐山":{"湊川":0.8},
"湊川":{"彩山親水公園":1.1},
"彩山親水公園":{"彩山":1.2},
"彩山":{"蓮華寺":0.8,"彩山口":2.1},
"蓮華寺":{"星宮":1.1},
"星宮":{"田ノ原":1.1},
"南新里":{"田ノ原":2.3},
"田ノ原":{"北玖川":2.4},
"北玖川":{"玖川":3.1},
"玖川":{"中野原":3.1},
"彩山口":{"新里国際スキー場":3.4},
"新里国際スキー場":{"鷹見台":10.7},
"鷹見台":{"久我原":2.7},
"久我原":{"浪原":1.5},
"浪原":{"深江":1.4,"桜鉄浪原":0.2},
"深江":{"三栗谷":1.3},
"三栗谷":{"桜川公園":1.5},
"桜川公園":{"桜川":2.2},
"北鶴宮":{"鬼越峠":2.6},
"鬼越峠":{"片牧町":3.1},
"片牧町":{"虹川":2.2},
"虹川":{"新的場":1.9},
"新的場":{"神道山口":2.8},
"神道山口":{"原津":2.6},
"原津":{"奥沢高原":1.7},
"奥沢高原":{"京新峡":2.0},
"京新峡":{"流沢温泉":1.9},
"流沢温泉":{"流沢温泉口":2.5},
"流沢温泉口":{"白木稲荷":2.0},
"白木稲荷":{"籾井":2.4},
"籾井":{"猫崎海岸":2.3},
"猫崎海岸":{"百合ヶ丘公園":2.1},
"百合ヶ丘公園":{"北河都":2.7},
"北河都":{"河都":2.1},
"河都":{"南河都":1.7},
"南河都":{"恋野宮":2.2},
"恋野宮":{"紅原台":2.4},
"紅原台":{"外神":2.4},
"外神":{"大三浜":1.9},
"大三浜":{"千種園":2.1},
"千種園":{"白砂":2.3},
"白砂":{"余田":2.2},
"余田":{"りんくう桜川":2.3},
"りんくう桜川":{"桜川国際空港(新里鉄道)":1.1,"桜川国際空港(桜川電鉄)":1.1},
"桜川国際空港(新里鉄道)":{"桜川国際空港(桜川電鉄)":0.1},
"富士町":{"艶華":1.1},
"艶華":{"夕陽ヶ浜":0.7},
"夕陽ヶ浜":{"甲部":1.0},
"甲部":{"虹松":0.8},
"虹松":{"豊海":0.9},
"豊海":{"発樫":0.8,"東豊海":1.8,"宮内":1.3},
"発樫":{"徳橋":1.0},
"徳橋":{"原葉":1.1},
"原葉":{"北成津":1.2},
"北成津":{"成津":1.1},
"大道寺":{"津垣":1.2,"松木":1.8,"真華":1.0},
"津垣":{"口松":0.9},
"口松":{"高座":0.8},
"高座":{"榎仏子":0.9},
"榎仏子":{"南築田":0.9},
"南築田":{"築田市":0.7},
"築田市":{"高越":1.0},
"高越":{"二番街":1.1},
"二番街":{"弦川":1.0},
"弦川":{"萱海":0.9},
"萱海":{"陣中原":0.8},
"陣中原":{"綿部":0.9},
"綿部":{"合浜":0.9},
"合浜":{"松橋":0.8},
"松橋":{"牛ヶ瀬":1.1,"元町本通":1.2},
"牛ヶ瀬":{"津塚":1.0},
"津塚":{"東成津":0.8},
"東成津":{"成津":1.2},
"成津":{"大町":1.1},
"大町":{"久末":1.3},
"久末":{"今橋学園前":0.9},
"今橋学園前":{"大弥又":0.8},
"大弥又":{"小弥又":0.9,"北稜":1.4},
"小弥又":{"土川":0.9},
"土川":{"新今橋":1.2},
"新今橋":{"今橋":1.3},
"糸島":{"西糸島":1.4},
"西糸島":{"平田":1.5},
"平田":{"文京町":1.7},
"文京町":{"東桜川":1.7},
"東桜川":{"桜川":1.5},
"桜川":{"豊野月見台":1.7,"公園東口":0.9,"南桜川":1.8},
"豊野月見台":{"豊野":1.6},
"豊野":{"西豊野":1.9,"新豊野":1.4},
"西豊野":{"白州川":1.5},
"白州川":{"春田":2.3},
"春田":{"桜峠":5.4,"南春田":1.8},
"桜峠":{"桑畑":6.3},
"桑畑":{"常盤台":1.8,"新桑畑":2.4,"北桑畑":1.6},
"常盤台":{"天津川":1.9},
"新桑畑":{"横山町":2.4},
"横山町":{"東天津":2.3},
"東天津":{"天津中原":2.2},
"天津中原":{"北中原":2.6,"南中原":3.1},
"北中原":{"大塚台":2.5},
"大塚台":{"観音寺":2.4},
"観音寺":{"香春町":2.5},
"香春町":{"芝原":2.5},
"芝原":{"":2.4,"都川":2.3},
"":{"":2.6},
"":{"":2.5},
"":{"滝原":2.3},
"滝原":{"南萩川":2.5},
"南萩川":{"萩川":2.4},
"萩川":{"平沢町":2.3,"守辻":1.7},
"平沢町":{"鶴原":2.6},
"鶴原":{"若葉台":2.7},
"若葉台":{"":2.5},
"":{"南内原":2.4},
"南内原":{"内原":2.2},
"内原":{"北原台":2.7},
"北原台":{"斑鳩宮前":2.8},
"斑鳩宮前":{"守川":2.6},
"守川":{"水都":2.5},
"水都":{"西水都":1.8},
"西水都":{"瀬戸川":1.9},
"瀬戸川":{"笠原":2.1},
"笠原":{"西笠原":1.8},
"西笠原":{"浅端":1.9},
"浅端":{"出見川":1.9},
"出見川":{"関戸":1.8},
"関戸":{"櫛田":1.7},
"櫛田":{"柳井原":1.8},
"柳井原":{"柳井港":1.5},
"南中原":{"旭町":2.9},
"旭町":{"川端":3.2},
"都川":{"":2.7},
"":{"":2.6},
"":{"栄":1.3},
"栄":{"韮郷公園前":1.5},
"韮郷公園前":{"韮郷":1.4},
"松木":{"南綾山":1.7},
"南綾山":{"桜陽台":1.3},
"桜陽台":{"出庭":1.6},
"出庭":{"小木橋":1.8},
"小木橋":{"布井":1.5},
"布井":{"井畔":1.4},
"井畔":{"北條":1.7},
"北條":{"佐山":1.9},
"佐山":{"福寺":1.3},
"福寺":{"旭口":1.6},
"旭口":{"増林":1.9},
"増林":{"田井島":1.4},
"田井島":{"飯野":1.1},
"飯野":{"鵜木":1.8},
"鵜木":{"東雲":1.3},
"東雲":{"北東雲":0.9},
"北東雲":{"大岡浜":1.4},
"大岡浜":{"上宿":1.7},
"上宿":{"下宿":1.3},
"下宿":{"驫木":1.3},
"驫木":{"朝治":1.8},
"朝治":{"尾野見":1.4},
"尾野見":{"前芝":1.9},
"前芝":{"後芝":1.0},
"後芝":{"上代":1.8},
"上代":{"東津村":1.3},
"東津村":{"古川大橋":1.6,"津村":1.2},
"古川大橋":{"下甲":1.7},
"下甲":{"谷山":1.5},
"谷山":{"秋郷":1.8},
"秋郷":{"作平":1.3},
"作平":{"北作平":1.2},
"北作平":{"扇原":1.9},
"扇原":{"大八木":1.5},
"大八木":{"出町":1.7},
"出町":{"さくら大谷":0.9},
"さくら大谷":{"小野":1.3},
"小野":{"笠岡":1.1},
"笠岡":{"中の内":1.5},
"中の内":{"萱尾":1.5},
"萱尾":{"内原":1.6},
"南東橋":{"前岡":1.1},
"前岡":{"砂郷":1.9},
"砂郷":{"陣内":1.6},
"陣内":{"南望町":1.3},
"南望町":{"作平":2.0},
"新地":{"南新地":1.2,"東新地":1.8},
"南新地":{"熊井":1.1},
"熊井":{"富町":1.3},
"富町":{"北濱石":1.2},
"北濱石":{"濱石":1.2},
"濱石":{"尼田":1.3},
"尼田":{"玉田":1.2},
"玉田":{"倉上":1.3},
"倉上":{"秋岡":1.2},
"秋岡":{"今川市":1.3,"宮川":2.1},
"今川市":{"石津台":1.2},
"石津台":{"北吉田":1.3},
"北吉田":{"牧町":1.1},
"牧町":{"吉田市":1.3},
"吉田市":{"大河":1.4},
"大河":{"井嶋田":1.3},
"井嶋田":{"井幡":1.4},
"井幡":{"床川北口":1.2},
"床川北口":{"床北公園前":1.3},
"床北公園前":{"磐谷":1.4},
"磐谷":{"又木":1.3},
"又木":{"床川市":1.4},
"床川市":{"旭原(床川急行電鉄)":1.5,"東床川":1.6,"床川南":1.3},
"旭原(床川急行電鉄)":{"山木":1.4},
"山木":{"宮田野":1.3},
"宮田野":{"戸倉":1.3},
"戸倉":{"外川崎":1.1,"戸倉本町":2.1},
"外川崎":{"東学園都市":1.3},
"東学園都市":{"床川学園都市":1.0},
"東床川":{"畠山":1.4},
"畠山":{"真沢":1.3},
"真沢":{"みなと西町":1.3},
"みなと西町":{"床川港":1.1},
"克己ヶ丘":{"柴岡":1.7},
"柴岡":{"新柴岡":1.7},
"新柴岡":{"亀浜":1.4},
"亀浜":{"湊塚公園":1.6},
"湊塚公園":{"三島崎":2.1},
"三島崎":{"三筋大宮":1.8},
"三筋大宮":{"襟ヶ谷":1.4},
"襟ヶ谷":{"時雨町":1.9,"大和ヶ丘":1.8},
"時雨町":{"珠洲":1.5},
"珠洲":{"栗浜":1.7},
"栗浜":{"大野城":0.9},
"大野城":{"郡津六番台":1.7},
"郡津六番台":{"東菅谷":1.4},
"東菅谷":{"菅谷":1.6},
"菅谷":{"菖蒲中央":1.2},
"公園東口":{"桜川公園北口":1.0},
"桜川公園北口":{"御厨":1.2},
"御厨":{"南深江":1.1},
"南深江":{"北深江":1.0},
"北深江":{"桜鉄浪原":1.1},
"桜鉄浪原":{"東浪原":2.2,"桜鉄久我原":2.1},
"東浪原":{"喜多瀬浜":2.1},
"喜多瀬浜":{"葵台":2.3,"喜多瀬":1.8},
"喜多瀬":{"久我山":1.7},
"久我山":{"桜鉄彩山口":1.9},
"葵台":{"汐見台":2.4},
"汐見台":{"月野原":2.2},
"月野原":{"高瀬":2.1},
"高瀬":{"結原":2.2},
"結原":{"りんくう桜川":2.0},
"床川南":{"久屋":2.1},
"久屋":{"知野場":2.4},
"知野場":{"何原":1.7},
"何原":{"土根":2.6},
"土根":{"中床川口":1.9},
"中床川口":{"床川口":1.2},
"床川口":{"押倉":2.1},
"押倉":{"尾奈居":2.6},
"尾奈居":{"賀根":3.1},
"賀根":{"江小野":3.4},
"江小野":{"赤塚台":3.3},
"赤塚台":{"赤塚新町":2.4,"御簾谷":1.4},
"御簾谷":{"下大原":2.3},
"下大原":{"赤塚口":2.5},
"赤塚口":{"大野部":2.8},
"大野部":{"黒髪":3.1},
"黒髪":{"沼の上":3.4},
"沼の上":{"瀬尾":3.6},
"瀬尾":{"沼の下":3.4},
"沼の下":{"烏田":3.3},
"烏田":{"大苫":2.9},
"大苫":{"上菊池":3.1},
"上菊池":{"権手":2.7},
"権手":{"床川学園都市":2.4},
"赤塚新町":{"二十四日":3.2},
"二十四日":{"古語町":3.5},
"古語町":{"北久野":3.6},
"北久野":{"野々垣":3.1},
"野々垣":{"油家":3.3},
"油家":{"大保":3.6},
"大保":{"筈山":5.2},
"筈山":{"妹子町":4.2},
"妹子町":{"下妹子":3.7},
"下妹子":{"風見井":3.8},
"風見井":{"山経":4.3},
"山経":{"河原橋":3.7},
"河原橋":{"東河原橋":3.4},
"東河原橋":{"千々羽":3.2},
"千々羽":{"枝皆":4.3},
"枝皆":{"湖多田":3.6},
"湖多田":{"摺名":3.1},
"摺名":{"大白石":3.5},
"大白石":{"東道学院前":1.2},
"東道学院前":{"紫芝":3.2},
"紫芝":{"反川":2.8},
"反川":{"北久地":2.7},
"北久地":{"南久地":2.5},
"南久地":{"蛇場":2.6},
"蛇場":{"上田興":2.3},
"上田興":{"師事野":2.4},
"師事野":{"夢の台":2.6},
"夢の台":{"緋野柴山":2.3},
"緋野柴山":{"緋野市":2.1},
"緋野市":{"南緋野":2.4},
"南緋野":{"道末":2.5},
"道末":{"二重寺":2.6},
"二重寺":{"蘭ヶ峰":2.3},
"蘭ヶ峰":{"芝の原":2.2},
"芝の原":{"北大虎":1.4},
"北大虎":{"大虎":1.1},
"大虎":{"翡翠橋":0.9},
"翡翠橋":{"浪川墾田町":0.8},
"浪川墾田町":{"浪川":0.6},
"新豊野":{"日野":1.8},
"日野":{"加納":1.9},
"加納":{"西永楽":2.1,"永楽町":1.9},
"西永楽":{"天津山下":2.3},
"天津山下":{"白金町":2.2},
"白金町":{"増枝":2.4},
"増枝":{"豊栄町":2.6},
"豊栄町":{"柿木橋":2.5},
"柿木橋":{"白梨町":2.4},
"白梨町":{"渡河":2.6},
"渡河":{"椚原":2.7},
"椚原":{"大岡":2.5},
"大岡":{"北緑川":2.4},
"北緑川":{"緑川":2.5},
"緑川":{"壇ノ原":2.4,"旭原(今橋鉄道)":1.8},
"壇ノ原":{"国府":1.8},
"国府":{"海田":1.9},
"海田":{"南海田":1.7},
"南海田":{"祗園橋":1.7},
"祗園橋":{"紋花町":1.8},
"紋花町":{"朱鷺橋":1.7},
"朱鷺橋":{"久知川":1.9},
"久知川":{"橘木":1.6},
"橘木":{"榛原":1.7},
"榛原":{"南榛原":1.5},
"南榛原":{"北戸倉":1.6},
"北戸倉":{"戸倉":1.4},
"戸倉本町":{"久志":2.2},
"久志":{"北天神":2.4},
"北天神":{"天神台":2.3},
"天神台":{"東瀬尾":2.4},
"東瀬尾":{"瀬尾":2.4},
"南春田":{"日野原":2.5},
"日野原":{"加納":2.7},
"永楽町":{"室町":1.8},
"室町":{"西新地":1.7},
"西新地":{"新地":1.9},
"東新地":{"東片野":1.8},
"南桜川":{"東豊野":1.8},
"東豊野":{"すすき野":1.9},
"すすき野":{"永田":2.2},
"永田":{"平川":2.1},
"平川":{"片野":2.3},
"片野":{"東片野":2.2},
"東片野":{"りんかい公園":1.8,"桜町":1.7},
"りんかい公園":{"新地港":1.4},
"北桑畑":{"坂川":1.6},
"坂川":{"天津川温泉":1.8},
"桜町":{"海岸通り":1.9},
"海岸通り":{"新浜":1.8},
"新浜":{"野瀬":1.7},
"野瀬":{"南糸島":1.6},
"南糸島":{"糸島":1.7},
"糸島":{"中洲":2.2},
"中洲":{"似島":2.3},
"似島":{"彩山川":1.5},
"彩山川":{"桜鉄浪原":2.4},
"中野":{"南中野":1.8,"西中野":1.9},
"南中野":{"大里":1.7},
"大里":{"栄町":1.9},
"栄町":{"北桜川":2.1},
"北桜川":{"桜川":1.8},
"桜鉄久我原":{"福原":2.4},
"福原":{"桜台":2.3},
"桜台":{"東中野":2.1},
"東中野":{"中野":1.9},
"西中野":{"川渡":2.2},
"川渡":{"八軒町":2.1},
"八軒町":{"木ノ葉台":2.7},
"木ノ葉台":{"北春田":4.3},
"北春田":{"春田":1.7},
"東豊海":{"牛見":1.7},
"牛見":{"三九十九":1.4},
"三九十九":{"":2.1},
"":{"深原":1.7},
"深原":{"南八幡":1.9},
"南八幡":{"榛葉":1.6},
"榛葉":{"山中":3.8},
"山中":{"大岡山":4.3},
"大岡山":{"藤宮":4.0},
"藤宮":{"継立":2.1},
"継立":{"緑川":1.9},
"旭原(今橋鉄道)":{"西国浜":2.0},
"西国浜":{"最黒":1.7},
"最黒":{"東栗山":1.4},
"東栗山":{"秋岡":1.8},
"宮川":{"寺島":1.7},
"元町本通":{"赤原":1.5},
"赤原":{"殿内":1.8},
"殿内":{"小金":1.7},
"小金本郷":{"栄浦":1.9},
"栄浦":{"尾田":1.8},
"尾田":{"五条":1.4},
"五条":{"積岡":1.7},
"積岡":{"襟ヶ谷":1.9},
"大和ヶ丘":{"福住":1.5},
"福住":{"白羽":1.6},
"白羽":{"東郷":2.0},
"東郷":{"岩内":1.7},
"岩内":{"南徳倉":1.5},
"南徳倉":{"徳倉":1.5},
"宮内":{"姫木":1.7},
"姫木":{"東小金":1.5},
"東小金":{"小金":1.4},
"小金":{"西小金":1.5,"小金本郷":1.4},
"西小金":{"杖原":1.9},
"杖原":{"東福寺":1.6},
"東福寺":{"西行":2.0},
"西行":{"出谷":1.7},
"出谷":{"古宮":1.8},
"古宮":{"外河原":2.1},
"外河原":{"坂下":1.8},
"坂下":{"田越":2.0},
"田越":{"掘割":1.5},
"掘割":{"妙花":1.7},
"妙花":{"西本町":1.9},
"西本町":{"新東雲":1.4},
"新東雲":{"東雲":1.2},
"岩川崎":{"南春原":1.6},
"南春原":{"元島":1.8},
"元島":{"西荻":2.1},
"西荻":{"神庄":2.2},
"神庄":{"萩川":1.9},
"守辻":{"南風野":1.9},
"南風野":{"東橋":1.7},
"津村":{"古川":1.3},
"古川":{"蓬原":1.2},
"蓬原":{"上須坂":1.4},
"上須坂":{"坂井田":1.3},
"坂井田":{"城戸":1.1},
"城戸":{"狩川":1.2},
"狩川":{"牧原":1.2},
"牧原":{"久和野":1.3},
"久和野":{"木浦":1.1},
"木浦":{"東高城":1.2},
"東高城":{"高城":1.4},
"高城":{"高城山":1.3},
"高城山":{"久居":1.2},
"久居":{"南笠原":1.3},
"南笠原":{"笠原":1.3},
"笠原":{"北笠原":1.2},
"北笠原":{"水都臨海公園":1.1},
"水都臨海公園":{"浜笠原":1.0},
"千鳥ヶ浜":{"東上橋":1.8},
"東上橋":{"上橋":1.2},
"上橋":{"連雀":1.4},
"連雀":{"樫ヶ谷":1.3},
"樫ヶ谷":{"球河":1.5},
"球河":{"舟林":1.6},
"舟林":{"鰯塚":1.3},
"鰯塚":{"鳩音台":1.1},
"鳩音台":{"飛魚":1.5},
"飛魚":{"帝国橋":1.2},
"帝国橋":{"鴫山":0.7},
"鴫山":{"柿崎":1.1},
"柿崎":{"鈴代":1.0},
"鈴代":{"新白鳥":1.1,"三葉公園":1.2},
"新白鳥":{"白鳥":0.8},
"白鳥":{"内原":1.2},
"三葉公園":{"尉鶲":1.0},
"尉鶲":{"燕ヶ丘":1.3},
"燕ヶ丘":{"銅台":1.3},
"銅台":{"観音通":1.1},
"観音通":{"白魚":1.2,"斑鳩":1.7},
"白魚":{"鷺濱":1.5},
"鷺濱":{"縞鯵":1.8},
"縞鯵":{"白洲":1.6},
"斑鳩":{"守川神宮":1.7},
"守川神宮":{"雁金台":1.5},
"雁金台":{"水都":1.6},
"北稜":{"桃野":1.1},
"桃野":{"秦戸":1.0},
"秦戸":{"鶴田":1.7},
"鶴田":{"太田井":1.2},
"太田井":{"池戸":1.4},
"池戸":{"島井":1.7},
"島井":{"七道":1.0},
"七道":{"布田":1.1},
"布田":{"築田医大前":1.3},
"築田医大前":{"下城":1.0},
"下城":{"水木":1.2},
"水木":{"飛江田":1.1},
"飛江田":{"中浜町":1.2},
"中浜町":{"大道寺":1.5},
"真華":{"白福":1.3},
"白福":{"有津":2.0},
"有津":{"馬原川":1.9},
"馬原川":{"緑地中央":1.7},
"緑地中央":{"玉岡":2.1},
"玉岡":{"西玉岡":1.5},
"西玉岡":{"浦江":1.9},
"浦江":{"鶴原":1.7},
"鶴原":{"岩藤公園":2.0},
"岩藤公園":{"三厨":1.4},
"三厨":{"亘谷":1.9},
"亘谷":{"東川":1.6},
"東川":{"狐山新町":1.8},
"狐山新町":{"秋部":2.0},
"秋部":{"東槻平":1.7},
"東槻平":{"槻平":1.5},
"槻平":{"新槻平":1.2},
"新槻平":{"矢附":1.8},
"矢附":{"塩塚":1.4},
"塩塚":{"槻平公園":1.7},
"槻平公園":{"内鴨川":1.3},
"内鴨川":{"寺内":1.9},
"寺内":{"鞍部":1.7},
"鞍部":{"村橋":2.0}
};


// --- ユーティリティ ---
function buildGraphBidirectional(raw){
  const g = {};
  for(const [a,edges] of Object.entries(raw)){
    if(!g[a]) g[a]={};
    for(const [b,d] of Object.entries(edges)){
      g[a][b]=d;
      if(!g[b]) g[b]={};
      if(g[b][a]==null) g[b][a]=d;
    }
  }
  return g;
}
const graph = buildGraphBidirectional(rawGraph);
const allStations = Array.from(new Set([...Object.keys(graph), ...Object.values(graph).flatMap(x => Object.keys(x))])).sort();

// ============ 運賃ロジック ============
function fareImabashi(km){
  if(km < 3) return 160;
  if(km < 6) return 180;
  if(km < 9) return 200;
  if(km < 12) return 220;
  if(km < 15) return 240;
  if(km < 18) return 260;
  if(km < 21) return 280;
  if(km < 24) return 300;
  if(km < 27) return 320;
  if(km < 30) return 340;
  if(km < 33) return 360;
  if(km < 36) return 380;
  if(km < 39) return 400;
  if(km < 42) return 420;
  if(km < 45) return 440;
  if(km < 48) return 460;
  if(km < 51) return 480;
  if(km < 54) return 500;
  if(km < 57) return 520;
  if(km < 60) return 540;
  return 560;
}
function fareSakuragawa(km){
  if(km<2)return 140;
  if(km<4)return 150;
  if(km<7)return 160;
  if(km<10)return 170;
  if(km<14)return 180;
  if(km<18)return 200;
  if(km<23)return 220;
  if(km<28)return 240;
  if(km<34)return 260;
  if(km<40)return 280;
  return 310;
}
function fareSeiou(km){ return 0; }
function fareChidori(km){ return 0; }
function fareKasahara(km){ 
  if(km<2)return 150;
  if(km<3)return 160;
  if(km<4)return 170;
  if(km<6)return 180;
  if(km<8)return 190;
  if(km<10)return 200;
  if(km<13)return 210;
  if(km<16)return 220;
  if(km<19)return 230;
  if(km<23)return 240;
  return 250;
}
function fareKogane(km){ return 0; }
function fareOkuwa(km){
  if(km < 3) return 150;
  if(km < 5) return 170;
  if(km < 9) return 210;
  if(km < 13) return 250;
  if(km < 18) return 300;
  if(km < 23) return 350;
  if(km < 28) return 400;
  if(km < 34) return 460;
  if(km < 40) return 520;
  if(km < 47) return 590;
  if(km < 54) return 660;
  if(km < 62) return 740;
  return 820;
}
function fareShinonome(km){
  if(km < 3) return 140;
  if(km < 6) return 160;
  if(km < 9) return 180;
  if(km < 12) return 200;
  if(km < 15) return 220;
  if(km < 18) return 240;
  if(km < 21) return 260;
  if(km < 24) return 280;
  if(km < 27) return 300;
  if(km < 30) return 320;
  if(km < 33) return 340;
  if(km < 36) return 360;
  if(km < 39) return 380;
  if(km < 42) return 400;
  if(km < 45) return 420;
  if(km < 48) return 440;
  if(km < 51) return 460;
  if(km < 54) return 480;
  if(km < 57) return 500;
  if(km < 60) return 520;
  return 540;
  }
function fareSakatsu(km){ return 0; }
function fareSakatsuPortliner(km){ return 0; }
function fareToyono(km){
  if (km < 2) return 140;
  if (km < 4) return 150;
  if (km < 6) return 170;
  if (km < 9) return 200;
  if (km < 12) return 230;
  if (km < 16) return 270;
  if (km < 20) return 310;
  if (km < 25) return 350;
  if (km < 30) return 400;
  if (km < 35) return 450;
  if (km < 40) return 500;
  if (km < 45) return 550;
  if (km < 50) return 600;
  if (km < 55) return 660;
  if (km < 60) return 720;
  if (km < 65) return 780;
  if (km < 70) return 840;
  if (km < 75) return 900;
  if (km < 80) return 960;
  if (km < 85) return 1020;
  if (km < 90) return 1080;
  if (km < 95) return 1140;
  return 1200;
}
function fareTokogawa(km) {
  if (km < 3)  return 120;
  if (km < 6)  return 160;
  if (km < 9)  return 200;
  if (km < 12) return 240;
  if (km < 15) return 280;
  if (km < 18) return 320;
  if (km < 21) return 360;
  if (km < 24) return 400;
  if (km < 27) return 440;
  if (km < 30) return 480;
  if (km < 33) return 520;
  if (km < 36) return 560;
  return 600; // 39kmを超える場合（必要なら延長可能）
}

function fareTouhashi(km){
  if(km < 3) return 180;
  if(km < 4) return 190;
  if(km < 7) return 210;
  if(km < 10) return 250;
  if(km < 14) return 330;
  if(km < 18) return 400;
  if(km < 23) return 470;
  if(km < 28) return 530;
  if(km < 33) return 590;
  if(km < 38) return 650;
  if(km < 43) return 690;
  if(km < 49) return 750;
  if(km < 55) return 810;
  if(km < 62) return 860;
  if(km < 69) return 910;
  if(km < 76) return 960;
  if(km < 84) return 1010;
  if(km < 92) return 1050;
  if(km < 100) return 1090;
  if(km < 109) return 1130;
  if(km < 120) return 1170;
  if(km < 132) return 1210;
  if(km < 145) return 1250;
  return 1250;
}
function fareNiizato(km){
  if(km<2)return 130;
  if(km<5)return 140;
  if(km<8)return 160;
  if(km<12)return 190;
  if(km<16)return 220;
  if(km<20)return 250;
  if(km<25)return 290;
  if(km<30)return 340;
  if(km<35)return 390;
  if(km<40)return 450;
  if(km<50)return 510;
  if(km<56)return 580;
  if(km<62)return 650;
  if(km<68)return 720;
  if(km<75)return 790;
  if(km<82)return 870;
  if(km<90)return 950;
  return 1040;
}
function fareSugaya(km){
  return 0;
}
function fareNamikawa(km){
  return 0;
}
function fareTsukihira(km){
  return 0;
}
// --- 路線名から会社名を判定 ---
function companyFromLineName(line){
  if(!line) return null;
  if(line.startsWith("今橋鉄道")) return "今橋鉄道";
  if(line.startsWith("小金鉄道")) return "小金鉄道";
  if(line.startsWith("大桑鉄道")) return "大桑鉄道";
  if(line.startsWith("東雲鉄道")) return "東雲鉄道";
  if(line.startsWith("桜川電気鉄道")) return "桜川電気鉄道";
  if(line.startsWith("桜津開発鉄道")) return "桜津開発鉄道";
  if(line.startsWith("坂津電鉄")) return "坂津電鉄";
  if(line.startsWith("坂津ポートライナー")) return "坂津ポートライナー";
  if(line.startsWith("豊野鉄道")) return "豊野鉄道";
  if(line.startsWith("東橋鉄道")) return "東橋鉄道";
  if(line.startsWith("新里鉄道")) return "新里鉄道";
  if(line.startsWith("菅谷高速鉄道")) return "菅谷高速鉄道";
  if(line.startsWith("床川急行電鉄")) return "床川急行電鉄";
  if(line.startsWith("浪川急行電鉄")) return "浪川急行電鉄";
  if(line.startsWith("笠原電気鉄道")) return "笠原電気鉄道";
  if(line.startsWith("槻平急行電鉄")) return "槻平急行電鉄";
  if(line.startsWith("千鳥鉄道")) return "千鳥鉄道";
  return null;
}
// --- 会社名と距離から運賃を取得 ---
function fareByCompany(company, km){
  switch(company){
    case "今橋鉄道": return fareImabashi(km);
    case "小金鉄道": return fareKogane(km);
    case "大桑鉄道": return fareOkuwa(km);
    case "東雲鉄道": return fareShinonome(km);
    case "桜川電気鉄道": return fareSakuragawa(km);
    case "西桜開発鉄道": return fareSeiou(km);
    case "坂津電鉄": return fareSakatsu(km);
    case "坂津ポートライナー": return fareSakatsuPortliner(km);
    case "豊野鉄道": return fareToyono(km);
    case "東橋鉄道": return fareTouhashi(km);
    case "新里鉄道": return fareNiizato(km);
    case "菅谷高速鉄道": return fareSugaya(km);
    case "床川急行電鉄": return fareTokogawa(km);
    case "浪川急行電鉄": return fareNamikawa(km);
    case "笠原電気鉄道": return fareKasahara(km);
    case "槻平急行電鉄": return fareTsukihira(km);
    case "千鳥鉄道": return fareChidori(km);
    default: return 0;
  }
}

function findLinesOfSegment(a,b){
  const candidates = [];
  for(const [line, stations] of Object.entries(stationLines)){
    const ia = stations.indexOf(a);
    const ib = stations.indexOf(b);
    if(ia === -1 || ib === -1) continue;
    // 1) 通常の隣接（インデックス差が1）
    if(Math.abs(ia - ib) === 1){
      candidates.push(line);
      continue;
    }
    // 2) 環状線対応：路線名に「環状」を含む路線では先頭と末尾を隣接とみなす
    const isCircular = /環状/.test(line);
    if(isCircular && stations.length > 1){
      if((ia === 0 && ib === stations.length - 1) || (ib === 0 && ia === stations.length - 1)){
        candidates.push(line);
        continue;
      }
    }
  }
  return candidates;
}
function findLineOfSegment(a,b){
  const cs = findLinesOfSegment(a,b);
  return cs.length ? cs[0] : null;
}

function shortestPath(start,goal){
  if(!graph[start] || !graph[goal]) return {path:[],distance:Infinity};
  const dist = {}, prev = {}, Q = new Set(allStations);
  allStations.forEach(s=>{ dist[s] = Infinity; prev[s] = null; });
  dist[start] = 0;
  while(Q.size){
    let u = null, best = Infinity;
    for(const v of Q){ if(dist[v] < best){ u = v; best = dist[v]; } }
    if(u === null) break;
    Q.delete(u);
    if(u === goal) break;
    for(const [v,w] of Object.entries(graph[u]||{})){
      const alt = dist[u] + w;
      if(alt < dist[v]){ dist[v] = alt; prev[v] = u; }
    }
  }
  if(!isFinite(dist[goal])) return {path:[],distance:Infinity};
  const path = []; for(let cur = goal; cur != null; cur = prev[cur]) path.unshift(cur);
  return {path, distance: dist[goal]};
}

function shortestPathWithinCompany(start, goal, company){
  if(!graph[start] || !graph[goal]) return {path:[],distance:Infinity};
  const dist = {}, prev = {}, Q = new Set(allStations);
  allStations.forEach(s=>{ dist[s] = Infinity; prev[s] = null; });
  dist[start] = 0;
  while(Q.size){
    let u = null, best = Infinity;
    for(const v of Q){ if(dist[v] < best){ u = v; best = dist[v]; } }
    if(u === null) break;
    Q.delete(u);
    if(u === goal) break;
    for(const [v,w] of Object.entries(graph[u]||{})){
      const ln = findLineOfSegment(u, v);
      const comp = ln ? companyFromLineName(ln) : null;
      if(comp !== company) continue;
      const alt = dist[u] + w;
      if(alt < dist[v]){ dist[v] = alt; prev[v] = u; }
    }
  }
  if(!isFinite(dist[goal])) return {path:[],distance:Infinity};
  const path = []; for(let cur = goal; cur != null; cur = prev[cur]) path.unshift(cur);
  return {path, distance: dist[goal]};
}

// ==== 途中駅扱いの「接続」定義 ====
const connectingStations = [
  { station: "鶴宮", endpoints: ["鶴宮神社","南鶴宮"] },
  { station: "湯の浜", endpoints: ["湯の浜海岸","新里大学前"] },
  { station: "彩山", endpoints: ["彩山親水公園","彩山口"] },
  { station: "桜川", endpoints: ["桜川公園","豊野月見台"] },
  { station: "港通", endpoints: ["坂電坂津", "東坂津"] },
  { station: "豊町", endpoints: ["削野", "東豊町"] },
  { station: "横宿", endpoints: ["日森町", "北横宿"] },
  { station: "成津", endpoints: ["北成津", "大町"] },
  { station: "桑畑", endpoints: ["北桑畑", "常盤台"] },
  { station: "園木", endpoints: ["東園木", "富士町"] },
  { station: "園木", endpoints: ["東園木", "大木沢"] },
  { station: "新東橋", endpoints: ["浅見", "矢崎"] },
  { station: "床川市", endpoints: ["又木", "床川南"] }
];

const specialMajorStations = [
  "湯の浜","鶴宮","港通","豊町","成津","園木","桑畑","新東橋","床川市"
];

function indexesOf(arr, value){
  const out=[]; for(let i=0;i<arr.length;i++) if(arr[i]===value) out.push(i); return out;
}
function betweenExclusive(idx, a, b){ return (a < idx && idx < b) || (b < idx && b < a); }

function findIndexFrom(path, station, start){
  for(let i=start;i<path.length;i++){
    if(path[i] === station) return i;
  }
  return -1;
}

// --- 主要駅抽出（元の関数は保持。表示上の主要駅判定はこの関数に従います） ---

function majorStops(path){
  if(path.length <= 1) return {majors: path};

  // --- 特例判定: 「豊野線 -> 園木 -> 東橋本線」を含むかチェック ---
  let isToyonoToHigashihashi = false;
  for(let i=0;i<path.length-2;i++){
    const ln1 = (findLineOfSegment(path[i], path[i+1]) || "");
    const ln2 = (findLineOfSegment(path[i+1], path[i+2]) || "");
    if(ln1.includes("豊野線") && ln2.includes("東橋本線")){
      isToyonoToHigashihashi = true;
      break;
    }
  }

  // connectingStations / specialMajorStations を場合分けで定義
  let connectingStations;
  let specialMajorStations;
  if(isToyonoToHigashihashi){
    // 特例: 新東橋を含めないバージョン
    connectingStations = [
      { station: "鶴宮", endpoints: ["鶴宮神社","南鶴宮"] },
      { station: "湯の浜", endpoints: ["湯の浜海岸","新里大学前"] },
      { station: "彩山", endpoints: ["彩山親水公園","彩山口"] },
      { station: "桜川", endpoints: ["桜川公園","豊野月見台"] },
      { station: "港通", endpoints: ["坂電坂津", "東坂津"] },
      { station: "豊町", endpoints: ["削野", "東豊町"] },
      { station: "横宿", endpoints: ["日森町", "北横宿"] },
      { station: "成津", endpoints: ["北成津", "大町"] },
      { station: "桑畑", endpoints: ["北桑畑", "常盤台"] },
      { station: "園木", endpoints: ["東園木", "富士町"] },
      { station: "園木", endpoints: ["東園木", "大木沢"] },
      { station: "床川市", endpoints: ["又木", "床川南"] }
    ];
    specialMajorStations = [
      "湯の浜","鶴宮","港通","豊町","成津","園木","桑畑","床川市"
    ];
  } else {
    // 通常: 新東橋を含むバージョン
    connectingStations = [
      { station: "鶴宮", endpoints: ["鶴宮神社","南鶴宮"] },
      { station: "湯の浜", endpoints: ["湯の浜海岸","新里大学前"] },
      { station: "彩山", endpoints: ["彩山親水公園","彩山口"] },
      { station: "桜川", endpoints: ["桜川公園","豊野月見台"] },
      { station: "港通", endpoints: ["坂電坂津", "東坂津"] },
      { station: "豊町", endpoints: ["削野", "東豊町"] },
      { station: "横宿", endpoints: ["日森町", "北横宿"] },
      { station: "成津", endpoints: ["北成津", "大町"] },
      { station: "桑畑", endpoints: ["北桑畑", "常盤台"] },
      { station: "園木", endpoints: ["東園木", "富士町"] },
      { station: "園木", endpoints: ["東園木", "大木沢"] },
      { station: "新東橋", endpoints: ["浅見", "矢崎"] },
      { station: "床川市", endpoints: ["又木", "床川南"] }
    ];
    specialMajorStations = [
      "湯の浜","鶴宮","港通","豊町","成津","園木","桑畑","新東橋","床川市"
    ];
  }

  // --- 以下は従来の主要駅判定ロジック（接続スキップ等を含む） ---
  const majors = [path[0]];
  let curLine = findLineOfSegment(path[0], path[1]);

  for(let i = 1; i < path.length; i++){
    const prev = path[i-1];
    const here = path[i];
    const ln = findLineOfSegment(prev, here);

    let isBoundary = (ln !== curLine);

    // specialMajorStations に含まれる駅が、前後とも同一路線なら主駅扱いをスキップ
    let isSpecialSkip = false;
    if(specialMajorStations.includes(here) && i > 0 && i < path.length-1){
      const before = path[i-1];
      const after  = path[i+1];
      if(findLineOfSegment(before, here) && findLineOfSegment(here, after)){
        isSpecialSkip = true;
      }
    }

    // 接続駅（connectingStations）に基づくスキップ判定（前とここ）
    let connectionSkipPrev = false;
    const connsPrev = connectingStations.filter(c => c.station === prev);
    if(connsPrev && connsPrev.length > 0){
      const idxPrev = i - 1;
      for(const conn of connsPrev){
        const idxsA = indexesOf(path, conn.endpoints[0]);
        const idxsB = indexesOf(path, conn.endpoints[1]);
        if(idxsA.length > 0 && idxsB.length > 0){
          let matched = false;
          outer: for(const ia of idxsA){
            for(const ib of idxsB){
              if(betweenExclusive(idxPrev, ia, ib)){
                matched = true;
                break outer;
              }
            }
          }
          if(matched){ connectionSkipPrev = true; break; }
        }
      }
    }

    let connectionSkipHere = false;
    const connsHere = connectingStations.filter(c => c.station === here);
    if(connsHere && connsHere.length > 0){
      const idxHere = i;
      for(const conn of connsHere){
        const idxsA = indexesOf(path, conn.endpoints[0]);
        const idxsB = indexesOf(path, conn.endpoints[1]);
        if(idxsA.length > 0 && idxsB.length > 0){
          let matched = false;
          outer2: for(const ia of idxsA){
            for(const ib of idxsB){
              if(betweenExclusive(idxHere, ia, ib)){
                matched = true;
                break outer2;
              }
            }
          }
          if(matched){ connectionSkipHere = true; break; }
        }
      }
    }

    const connectionSkip = connectionSkipPrev || connectionSkipHere;

    if(isBoundary && !isSpecialSkip && !connectionSkip){
      majors.push(prev);
      curLine = ln;
    } else {
      curLine = ln;
    }
  }

  majors.push(path[path.length-1]);
  return {majors};
}


function findCommonLines(a,b){
  const list = [];
  for(const [line,stations] of Object.entries(stationLines)){
    if(stations.indexOf(a) !== -1 && stations.indexOf(b) !== -1) list.push(line);
  }
  return list;
}

// --- UI 初期化 ---
const fromLineSel = document.getElementById('fromLine');
const toLineSel = document.getElementById('toLine');
const fromStationSel = document.getElementById('fromStation');
const toStationSel = document.getElementById('toStation');
const addViaBtn = document.getElementById('addViaBtn');
const viaListDiv = document.getElementById('viaList');
const searchBtn = document.getElementById('searchBtn');
const resultArea = document.getElementById('resultArea');
const resultTabs = document.getElementById('resultTabs');
let tabButtons = resultTabs ? Array.from(resultTabs.querySelectorAll('.tabBtn')) : [];

// helper to refresh tabButtons (in case we ever recreate tabs)
function refreshTabButtons(){
  tabButtons = resultTabs ? Array.from(resultTabs.querySelectorAll('.tabBtn')) : [];
}
refreshTabButtons();



function populateLineSelect(sel){
  sel.innerHTML = '';
  const companyGroups = {};
  for(const line in stationLines){
    if(line === "徒歩乗換") continue;
    const companyMatch = line.match(/^(.*?)(鉄道|電鉄|高速鉄道|急行電鉄|ポートライナー)/);
    const company = companyMatch ? companyMatch[0] : "その他";
    if(!companyGroups[company]) companyGroups[company] = [];
    companyGroups[company].push(line);
  }

  for(const [company, lines] of Object.entries(companyGroups)){
    const optgroup = document.createElement('optgroup');
    optgroup.label = company;
    lines.forEach(lineFull => {
      // 安全に路線表示名を作る：会社名が先頭にある場合だけ切り取る（意図しない部分削除を防ぐ）
      let displayName = lineFull;
      const companyMatchInner = lineFull.match(/^(.*?)(鉄道|電鉄|高速鉄道|急行電鉄|ポートライナー)/);
      const companyInner = companyMatchInner ? companyMatchInner[0] : "";
      if(companyInner && displayName.startsWith(companyInner)){
        displayName = displayName.slice(companyInner.length);
      }
      // 先頭に残る一般的な語（鉄道/電鉄/の など）を削る
      displayName = displayName.replace(/^(鉄道|電鉄|高速鉄道|急行電鉄|ポートライナー|の)+/, '');
      displayName = displayName.trim();
      if(!displayName) displayName = lineFull;
      // 表示名が '線' のように短すぎる場合、元の lineFull を使う（例：桜津開発鉄道線 の場合など）
      if(displayName.length <= 2 || /^線$/.test(displayName)) {
        displayName = lineFull;
      }
 // 万一空になれば元の名前にフォールバック

      // 特例：彩山線 / 内原線 は従来通り会社名を括弧で付ける
      if(/彩山線/.test(lineFull)) displayName = "彩山線（" + (companyInner || company) + "）";
      if(/内原線/.test(lineFull)) displayName = "内原線（" + (companyInner || company) + "）";
      // 本線の特例は以下の条件でのみ適用する：
      //  - 行名が単独で「本線」である場合（例: "本線"）
      //  - または行名の接頭辞が会社名と一致している場合（例: "床川急行電鉄本線" -> 会社名が"床川急行電鉄"）
      if(/本線$/.test(lineFull)){
        const prefix = lineFull.replace(/本線$/, '');
        const comp = (companyInner || company) || '';
        if(prefix === ''){
          // 行名が単独で「本線」の場合は会社名があれば付ける
          displayName = '本線' + (comp ? '（' + comp.replace(/の$/, '').trim() + '）' : '');
        } else if(comp && prefix === comp){
          // 会社名+本線 の場合のみ本線（会社名）に変換
          displayName = '本線（' + comp.replace(/の$/, '').trim() + '）';
        }
        // それ以外（地名+本線 等）は特例の対象外にする（displayName は変更しない）
      }

      const o = document.createElement('option');
      o.value = lineFull;
      o.textContent = displayName;
      const color = lineColors[lineFull] || "#ccc";
      // 下線風に見せる：下部に高さ4pxの帯を描画（多くのブラウザで見た目が安定）
      o.style.backgroundImage = `linear-gradient(to bottom, transparent calc(100% - 4px), ${color} 4px)`;
      o.style.backgroundRepeat = 'no-repeat';
      o.style.backgroundSize = '100% 4px';
      o.setAttribute('data-color', color);
      o.style.setProperty('--line-color', color);;
      optgroup.appendChild(o);
    });
sel.appendChild(optgroup);
  }
}
function populateStationSelect(lineSel, stationSel){
  stationSel.innerHTML = '';
  const line = lineSel.value;
  (stationLines[line] || []).forEach(st=>{
    const o = document.createElement('option'); o.value = st; o.textContent = displayStationName(st); stationSel.appendChild(o);
  });
}
[ fromLineSel, toLineSel ].forEach(sel => populateLineSelect(sel));
populateStationSelect(fromLineSel, fromStationSel);
populateStationSelect(toLineSel, toStationSel);

fromLineSel.addEventListener('change', ()=> { populateStationSelect(fromLineSel, fromStationSel); saveSelections(); });
toLineSel.addEventListener('change', ()=> { populateStationSelect(toLineSel, toStationSel); saveSelections(); });
fromStationSel.addEventListener('change', saveSelections);
toStationSel.addEventListener('change', saveSelections);

// --- 保存 / 復元 ---
const STORAGE_KEY = 'niizato_prev_selection_v1';

function saveSelections(){
  try{
    const viaRows = Array.from(viaListDiv.querySelectorAll('.viaRow'));
    const via = viaRows.map(r=>{
      const ls = r.querySelector('.lineSelect');
      const ss = r.querySelector('.stationSelect');
      return { line: ls ? ls.value : null, station: ss ? ss.value : null };
    }).filter(v => v.line && v.station);
    const payload = {
      fromLine: fromLineSel.value || null,
      fromStation: fromStationSel.value || null,
      toLine: toLineSel.value || null,
      toStation: toStationSel.value || null,
      via
    };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
  }catch(e){
    // ignore
  }
}

function clearViaList(){
  viaListDiv.innerHTML = '';
}

function createViaRow(lineVal, stationVal){
  const viaRow = document.createElement('div');
  viaRow.className = 'viaRow';
  const lineSel = document.createElement('select');
  lineSel.className = 'lineSelect';
  populateLineSelect(lineSel);
  const stationSel = document.createElement('select');
  stationSel.className = 'stationSelect';
  populateStationSelect(lineSel, stationSel);
  lineSel.value = lineVal || lineSel.value;
  populateStationSelect(lineSel, stationSel);
  stationSel.value = stationVal || stationSel.value;

  lineSel.addEventListener('change', ()=> { populateStationSelect(lineSel, stationSel); saveSelections(); });
  stationSel.addEventListener('change', saveSelections);

  const delBtn = document.createElement('button');
  delBtn.type = 'button';
  delBtn.textContent = '削除';
  delBtn.addEventListener('click', ()=> { viaListDiv.removeChild(viaRow); saveSelections(); });
  viaRow.appendChild(lineSel);
  viaRow.appendChild(stationSel);
  viaRow.appendChild(delBtn);
  viaListDiv.appendChild(viaRow);
  return viaRow;
}

function loadSelections(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw){
      // 既定値（従来の既定）
      if(stationLines['新里鉄道湯の浜線'] && stationLines['新里鉄道湯の浜線'].indexOf('新里')!==-1){
        fromLineSel.value = '新里鉄道湯の浜線';
        populateStationSelect(fromLineSel, fromStationSel);
        fromStationSel.value = '新里';
      }
      if(stationLines['新里鉄道燠野線'] && stationLines['新里鉄道燠野線'].indexOf('燠野温泉')!==-1){
        toLineSel.value = '新里鉄道燠野線';
        populateStationSelect(toLineSel, toStationSel);
        toStationSel.value = '燠野温泉';
      }
      return;
    }
    const obj = JSON.parse(raw);
    if(obj.fromLine && stationLines[obj.fromLine]){
      fromLineSel.value = obj.fromLine;
      populateStationSelect(fromLineSel, fromStationSel);
      if(obj.fromStation && Array.from(fromStationSel.options).some(o=>o.value===obj.fromStation)){
        fromStationSel.value = obj.fromStation;
      }
    }
    if(obj.toLine && stationLines[obj.toLine]){
      toLineSel.value = obj.toLine;
      populateStationSelect(toLineSel, toStationSel);
      if(obj.toStation && Array.from(toStationSel.options).some(o=>o.value===obj.toStation)){
        toStationSel.value = obj.toStation;
      }
    }
    clearViaList();
    if(Array.isArray(obj.via)){
      for(const v of obj.via){
        if(v && v.line && stationLines[v.line] && v.station){
          createViaRow(v.line, v.station);
        }
      }
    }
  }catch(e){
    // on error fallback to defaults
    if(stationLines['新里鉄道湯の浜線'] && stationLines['新里鉄道湯の浜線'].indexOf('新里')!==-1){
      fromLineSel.value = '新里鉄道湯の浜線';
      populateStationSelect(fromLineSel, fromStationSel);
      fromStationSel.value = '新里';
    }
    if(stationLines['新里鉄道燠野線'] && stationLines['新里鉄道燠野線'].indexOf('燠野温泉')!==-1){
      toLineSel.value = '新里鉄道燠野線';
      populateStationSelect(toLineSel, toStationSel);
      toStationSel.value = '燠野温泉';
    }
  }
}

// 初期ロード
loadSelections();

// via追加
addViaBtn.addEventListener('click', ()=>{
  createViaRow(null, null);
  saveSelections();
});

// レイアウト補助（元ロジックを保持）
function applyStripedGradientForBigLine(lineElem, dotRect, nextDotRect, parentRect){
  if(!lineElem) return;
  // 徒歩乗換専用ストライプ処理
  const usedLinesRawCheck = lineElem.dataset.usedlines || '';
  if (usedLinesRawCheck.includes('徒歩乗換')) {
    lineElem.style.background = `repeating-linear-gradient(
      to bottom,
      #aaa 0px,
      #aaa 12px,
      #fff 12px,
      #fff 24px
    )`;
    return;
  }
  if(!lineElem) return;
  const baseColor = lineElem.dataset.color || '#999';
  const usedLinesRaw = lineElem.dataset.usedlines || '';
  const usedLinesArr = usedLinesRaw ? usedLinesRaw.split('|').filter(x=>x) : [];

  const lineTop = parseFloat(lineElem.style.top) || 0;
  const lineHeight = parseFloat(lineElem.style.height) || 0;
  if(lineHeight <= 0){
    lineElem.style.background = baseColor;
    return;
  }

  const currentDotBottom_px = (dotRect.top - parentRect.top) + dotRect.height;
  const nextDotTop_px = (nextDotRect.top - parentRect.top);

  const startPx = currentDotBottom_px - lineTop;
  const endPx = nextDotTop_px - lineTop;

  const clampedStartPx = Math.max(0, Math.min(lineHeight, startPx));
  const clampedEndPx = Math.max(0, Math.min(lineHeight, endPx));

  if(clampedEndPx <= clampedStartPx){
    if(usedLinesArr.length === 1){
      lineElem.style.background = lineColors[usedLinesArr[0]] || baseColor;
    } else {
      lineElem.style.background = baseColor;
    }
    return;
  }

  const startPercent = (clampedStartPx / lineHeight) * 100;
  const endPercent = (clampedEndPx / lineHeight) * 100;

  let gradientStops = [];
  gradientStops.push(`${baseColor} 0%`);
  gradientStops.push(`${baseColor} ${startPercent.toFixed(4)}%`);

  if(usedLinesArr.length > 0){
    const segCount = usedLinesArr.length;
    const segSize = (endPercent - startPercent) / segCount;
    for(let j=0;j<segCount;j++){
      const ln = usedLinesArr[j];
      const col = lineColors[ln] || baseColor;
      const segStart = startPercent + segSize * j;
      const segEnd = startPercent + segSize * (j+1);
      gradientStops.push(`${col} ${segStart.toFixed(4)}%`);
      gradientStops.push(`${col} ${segEnd.toFixed(4)}%`);
    }
  } else {
    gradientStops.push(`${baseColor} ${startPercent.toFixed(4)}%`);
    gradientStops.push(`${baseColor} 100%`);
  }

  const stopsStr = gradientStops.join(', ');
  lineElem.style.background = `linear-gradient(to bottom, ${stopsStr})`;
}

// *** adjustMajorLines を修正：非表示要素はスキップ（これで「再検索で線が消える」問題を解消） ***
function adjustMajorLines(){
  const rows = Array.from(document.querySelectorAll('.rowStation'));
  rows.forEach((row, idx) => {
    // 非表示（display:none 等）はスキップ
    if(!row.offsetParent) return;
    const railCol = row.querySelector('.railCol');
    if(!railCol) return;
    const dot = railCol.querySelector('.railDot');
    const line = railCol.querySelector('.railLineMajor');
    if (!dot || !line) return;
    if(line.dataset && line.dataset.shortened === 'true'){ return; }
colorWalkTransferStartDots();
    const nextRow = rows.slice(idx + 1).find(r => r.querySelector('.railDot') && r.offsetParent);
    if (!nextRow) { line.style.height = '0px'; return; }
    const parentRect = railCol.getBoundingClientRect();
    const dotRect = dot.getBoundingClientRect();
    const nextDot = nextRow.querySelector('.railDot');
    const nextDotRect = nextDot.getBoundingClientRect();
    line.style.top = (dotRect.top - parentRect.top) + 'px';
    const h = Math.max(0, (nextDotRect.top - dotRect.top)) + 5;
    line.style.height = h + 'px';
    applyStripedGradientForBigLine(line, dotRect, nextDotRect, parentRect);

    // bus overlay: if this big line has an overlay element (rendered for bus lines), position it so it avoids the dot area
    try{
      const overlay = document.getElementById(line.id + '-overlay');
      if(overlay){
        overlay.style.width = '1px';
        const topPx = Math.max(0, dotRect.bottom - parentRect.top);
        const overlayHeight = Math.max(0, nextDotRect.top - dotRect.bottom);
        overlay.style.top = topPx + 'px';
        overlay.style.height = overlayHeight + 'px';
      }
    }catch(e){}
    
  });

  document.querySelectorAll('.rowBetween').forEach(r => {
    if(!r.offsetParent) return;
    const railCol = r.querySelector('.railCol');
    if(!railCol) return;
    const dot = r.querySelector('.railDot');
    const minorLine = r.querySelector('.railLineMinor');
    if(!dot || !minorLine) return;
    const parentRect = railCol.getBoundingClientRect();
    const dotRect = dot.getBoundingClientRect();
    minorLine.style.top = (dotRect.top - parentRect.top) + 'px';
    minorLine.style.height = '48px';
    // bus overlay for minor lines (between-list)
    try{
      const overlay = r.querySelector('.busOverlay');
      if(overlay){
        const dotRect2 = dot.getBoundingClientRect();
        const topPx2 = Math.max(0, dotRect2.bottom - parentRect.top);
        const overlayH2 = Math.max(0, parseFloat(minorLine.style.height) - (dotRect2.bottom - dotRect2.top));
        overlay.style.top = topPx2 + 'px';
        overlay.style.height = overlayH2 + 'px';
        overlay.style.width = '1px';
      }
    }catch(e){}
  });
}
function runAdjustments(){ adjustMajorLines(); }
window.addEventListener('resize', runAdjustments);

/* =========================
   新実装（変更）: 「主要駅数を最小化」する探索
   - 状態を (node, prevLine) の組で扱い、線の切替が発生したとき主要カウントを +1
   - ただし、切替が発生する駅（u）が connectingStations の station に含まれる場合はカウントしない（＝途中駅扱いを除外）
   - コストは (majorCount, distance) の辞書順（majorCount を最小化、同数なら距離最小）
   ========================= */

function keyOfState(station, prevLine){ return station + '|||' + (prevLine || ''); }
function parseStateKey(key){
  const idx = key.indexOf('|||');
  const station = key.slice(0, idx);
  const prevLine = key.slice(idx+3) || null;
  return {station, prevLine};
}

function isConnectingStationName(name){
  return connectingStations.some(c => c.station === name);
}

function shortestPathMinMajors(start, goal, forbidden){
  if(!graph[start] || !graph[goal]) return {path:[],distance:Infinity};
  // distMap: key => {majors, dist}
  const distMap = new Map();
  const prevState = new Map(); // key => prevKey
  const Q = new Set();

  const startKey = keyOfState(start, '');
  distMap.set(startKey, {majors:0, dist:0});
  Q.add(startKey);

  while(Q.size){
    // pick best by (majors, dist)
    let bestKey = null; let bestMaj = Infinity; let bestDist = Infinity;
    for(const k of Q){
      const v = distMap.get(k);
      if(!v) continue;
      if(v.majors < bestMaj || (v.majors === bestMaj && v.dist < bestDist)){
        bestKey = k; bestMaj = v.majors; bestDist = v.dist;
      }
    }
    if(bestKey === null) break;
    Q.delete(bestKey);
    const {station: u, prevLine: prevLineOfU} = parseStateKey(bestKey);
    const curCost = distMap.get(bestKey);

    if(u === goal){
      const pathStations = [];
      let curKey = bestKey;
      while(curKey){
        const {station: st} = parseStateKey(curKey);
        pathStations.push(st);
        curKey = prevState.get(curKey) || null;
      }
      pathStations.reverse();
      let trueDist = 0;
      for(let i=0;i<pathStations.length-1;i++){
        const a = pathStations[i], b = pathStations[i+1];
        if(graph[a] && typeof graph[a][b] === 'number') trueDist += graph[a][b];
        else if(graph[b] && typeof graph[b][a] === 'number') trueDist += graph[b][a];
      }
      return {path: pathStations, distance: trueDist, majors: curCost.majors};
    }

    for(const [v,w] of Object.entries(graph[u]||{})){
      if(forbidden.has(v) && v !== goal) continue;
      const ln = findLineOfSegment(u, v) || '';
      let inc = 0;
      if(prevLineOfU && prevLineOfU !== '' && ln !== prevLineOfU){
        // line-change occurs at u; count it as major only if u is NOT a connectingStation
        if(!isConnectingStationName(u)){
          inc = 1;
        } else {
          inc = 0; // 接続駅は途中駅扱いなので増やさない
        }
      }
      const newMaj = curCost.majors + inc;
      const newDist = curCost.dist + w;
      const vKey = keyOfState(v, ln);

      const existing = distMap.get(vKey);
      const better = !existing || (newMaj < existing.majors) || (newMaj === existing.majors && newDist < existing.dist);
      if(better){
        distMap.set(vKey, {majors: newMaj, dist: newDist});
        prevState.set(vKey, bestKey);
        Q.add(vKey);
      }
    }
  }

  // fallback: choose best among states at goal if present
  let bestGoalKey = null; let bestMaj = Infinity; let bestDist = Infinity;
  for(const [k, v] of distMap.entries()){
    const {station} = parseStateKey(k);
    if(station === goal){
      if(v.majors < bestMaj || (v.majors === bestMaj && v.dist < bestDist)){
        bestGoalKey = k; bestMaj = v.majors; bestDist = v.dist;
      }
    }
  }
  if(!bestGoalKey) return {path:[],distance:Infinity};

  const pathStations = [];
  let curKey = bestGoalKey;
  while(curKey){
    const {station: st} = parseStateKey(curKey);
    pathStations.push(st);
    curKey = prevState.get(curKey) || null;
  }
  pathStations.reverse();
  let trueDist = 0;
  for(let i=0;i<pathStations.length-1;i++){
    const a = pathStations[i], b = pathStations[i+1];
    if(graph[a] && typeof graph[a][b] === 'number') trueDist += graph[a][b];
    else if(graph[b] && typeof graph[b][a] === 'number') trueDist += graph[b][a];
  }
  return {path: pathStations, distance: trueDist, majors: bestMaj};
}


function shortestPathMinTransfers(start, goal, forbidden){
  if(!graph[start] || !graph[goal]) return {path:[],distance:Infinity};
  // distMap: key => {transfers, dist}
  const distMap = new Map();
  const prevState = new Map();
  const Q = new Set();

  const startKey = keyOfState(start, '');
  distMap.set(startKey, {transfers:0, dist:0});
  Q.add(startKey);

  while(Q.size){
    // pick best by (transfers, dist)
    let bestKey = null; let bestTrans = Infinity; let bestDist = Infinity;
    for(const k of Q){
      const v = distMap.get(k);
      if(!v) continue;
      if(v.transfers < bestTrans || (v.transfers === bestTrans && v.dist < bestDist)){
        bestKey = k; bestTrans = v.transfers; bestDist = v.dist;
      }
    }
    if(bestKey === null) break;
    Q.delete(bestKey);
    const {station: u, prevLine: prevLineOfU} = parseStateKey(bestKey);
    if(forbidden.has(u) && u !== start && u !== goal) continue;
    if(u === goal){
      // we found goal with minimal transfers/dist among queued states; reconstruct path
      let path = [];
      let cur = bestKey;
      while(cur){
        const ps = parseStateKey(cur);
        path.unshift(ps.station);
        cur = prevState.get(cur);
      }
      return { path, distance: distMap.get(bestKey).dist };
    }
    // explore neighbors
    for(const [v,w] of Object.entries(graph[u]||{})){
      // get candidate lines between u and v
      const candidateLines = findLinesOfSegment(u, v);
      if(!candidateLines || candidateLines.length === 0){
        // still allow transition with unknown line
        const vKey = keyOfState(v, '');
        const cur = distMap.get(bestKey);
        const existing = distMap.get(vKey);
        const newTrans = cur.transfers;
        const newDist = cur.dist + w;
        if(!existing || newTrans < existing.transfers || (newTrans === existing.transfers && newDist < existing.dist)){
          distMap.set(vKey, {transfers:newTrans, dist:newDist});
          prevState.set(vKey, bestKey);
          Q.add(vKey);
        }
      } else {
        for(const ln of candidateLines){
          const compPrev = prevLineOfU ? companyFromLineName(prevLineOfU) : null;
          const compCur = companyFromLineName(ln);
          let inc = 0;
          if(prevLineOfU && compPrev && compCur && compPrev !== compCur){
            // company change => transfer
            // but if u is a connectingStationName, we may or may not count; follow existing logic: don't count if connectingStationName(u)
            if(!isConnectingStationName(u)) inc = 1;
          }
          const vKey = keyOfState(v, ln);
          const cur = distMap.get(bestKey);
          const newTrans = cur.transfers + inc;
          const newDist = cur.dist + w;
          const existing = distMap.get(vKey);
          if(!existing || newTrans < existing.transfers || (newTrans === existing.transfers && newDist < existing.dist)){
            distMap.set(vKey, {transfers:newTrans, dist:newDist});
            prevState.set(vKey, bestKey);
            Q.add(vKey);
          }
        }
      }
    }
  }

  // find best goal state among distMap keys
  let bestGoalKey = null; let bestT = Infinity; let bestD = Infinity;
  for(const [k,v] of distMap.entries()){
    const parsed = parseStateKey(k);
    if(parsed.station !== goal) continue;
    if(v.transfers < bestT || (v.transfers === bestT && v.dist < bestD)){
      bestGoalKey = k; bestT = v.transfers; bestD = v.dist;
    }
  }
  if(!bestGoalKey) return {path:[],distance:Infinity};
  let path = []; let cur = bestGoalKey;
  while(cur){
    const ps = parseStateKey(cur);
    path.unshift(ps.station);
    cur = prevState.get(cur);
  }
  return { path, distance: distMap.get(bestGoalKey).dist };
}

/* =========================
   既存の「一筆書き（重複禁止）ルート作成」ロジック（距離優先）
   (元プログラムのロジックを保持)
   ========================= */

// start->goal を forbidden を避けて最短経路を求める Dijkstra（再利用）
function shortestPathAvoiding(start, goal, forbidden){
  if(!graph[start] || !graph[goal]) return {path:[],distance:Infinity};
  const dist = {}, prev = {}, Q = new Set(allStations);
  allStations.forEach(s=>{ dist[s] = Infinity; prev[s] = null; });
  dist[start] = 0;

  while(Q.size){
    let u = null, best = Infinity;
    for(const v of Q){
      if(dist[v] < best){ u = v; best = dist[v]; }
    }
    if(u === null) break;
    Q.delete(u);

    if(forbidden.has(u) && u !== start && u !== goal) continue;
    if(u === goal) break;

    for(const [v,w] of Object.entries(graph[u]||{})){
      if(forbidden.has(v) && v !== goal) continue;
      const alt = dist[u] + w;
      if(alt < dist[v]){ dist[v] = alt; prev[v] = u; }
    }
  }

  if(!isFinite(dist[goal])) return {path:[],distance:Infinity};
  const path = []; for(let cur = goal; cur != null; cur = prev[cur]) path.unshift(cur);
  return {path, distance: dist[goal]};
}

// buildRoutePartsNoOverlap（元の距離優先のまま）
function buildRoutePartsNoOverlap(from, viaStations, to){
  const waypoints = [from, ...viaStations, to];
  let full = [];
  let totalDist = 0;
  const used = new Set();

  for(let i=0;i<waypoints.length-1;i++){
    const a = waypoints[i], b = waypoints[i+1];
    const forbidden = new Set(used);
    if(forbidden.has(a)) forbidden.delete(a);
    if(forbidden.has(b)) forbidden.delete(b);

    const sp = shortestPathAvoiding(a, b, forbidden);
    if(!sp.path || sp.path.length === 0) {
      const sp2 = shortestPath(a, b);
      if(!sp2.path || sp2.path.length === 0) return null;
      const seg2 = (i===0) ? sp2.path.slice() : sp2.path.slice(1);
      full.push(...seg2);
      totalDist += sp2.distance;
      for(const st of sp2.path){ if(st !== b) used.add(st); }
      continue;
    }

    const seg = (i===0) ? sp.path.slice() : sp.path.slice(1);
    full.push(...seg);
    totalDist += sp.distance;
    for(const st of sp.path){ if(st !== b) used.add(st); }
  }

  if(full.length === 0) return [];

  function splitOnTripleRepeat(fullPath){
    if(!Array.isArray(fullPath) || fullPath.length === 0) return [fullPath.slice()];
    const parts = [];
    let curStart = 0;
    for(let i = 2; i < fullPath.length; i++){
      if(fullPath[i-2] === fullPath[i]){
        const firstPart = fullPath.slice(curStart, i);
        if(firstPart.length > 1) parts.push(firstPart);
        curStart = i - 1;
      }
    }
    const last = fullPath.slice(curStart);
    if(last.length > 1) parts.push(last);
    return parts;
  }

  function distanceOfPath(p){
    if(!p || p.length < 2) return 0;
    let d = 0;
    for(let i=0;i<p.length-1;i++){
      const a = p[i], b = p[i+1];
      if(typeof graph !== 'undefined' && graph && graph[a] && typeof graph[a][b] === 'number') d += graph[a][b];
      else if(typeof graph !== 'undefined' && graph && graph[b] && typeof graph[b][a] === 'number') d += graph[b][a];
      else d += 0;
    }
    return d;
  }

  const splitted = splitOnTripleRepeat(full);
  const outParts = splitted.map(p => ({ path: p, distance: distanceOfPath(p) }));
  return outParts;
}

// buildRoutePartsNoOverlapMinMajors：主要駅数最小化版（距離は二次評価）
// 各区間で shortestPathMinMajors を使用
function buildRoutePartsNoOverlapMinMajors(from, viaStations, to){
  const waypoints = [from, ...viaStations, to];
  let full = [];
  let totalDist = 0;
  const used = new Set();

  for(let i=0;i<waypoints.length-1;i++){
    const a = waypoints[i], b = waypoints[i+1];
    const forbidden = new Set(used);
    if(forbidden.has(a)) forbidden.delete(a);
    if(forbidden.has(b)) forbidden.delete(b);

    const sp = shortestPathMinMajors(a, b, forbidden);
    if(!sp.path || sp.path.length === 0){
      const sp2 = shortestPathAvoiding(a, b, forbidden);
      if(!sp2.path || sp2.path.length === 0){
        const sp3 = shortestPath(a, b);
        if(!sp3.path || sp3.path.length === 0) return null;
        const seg3 = (i===0) ? sp3.path.slice() : sp3.path.slice(1);
        full.push(...seg3);
        totalDist += sp3.distance;
        for(const st of sp3.path){ if(st !== b) used.add(st); }
        continue;
      } else {
        const seg2 = (i===0) ? sp2.path.slice() : sp2.path.slice(1);
        full.push(...seg2);
        totalDist += sp2.distance;
        for(const st of sp2.path){ if(st !== b) used.add(st); }
        continue;
      }
    }

    const seg = (i===0) ? sp.path.slice() : sp.path.slice(1);
    full.push(...seg);
    totalDist += sp.distance;
    for(const st of sp.path){ if(st !== b) used.add(st); }
  }

  if(full.length === 0) return [];

  function splitOnTripleRepeat(fullPath){
    if(!Array.isArray(fullPath) || fullPath.length === 0) return [fullPath.slice()];
    const parts = [];
    let curStart = 0;
    for(let i = 2; i < fullPath.length; i++){
      if(fullPath[i-2] === fullPath[i]){
        const firstPart = fullPath.slice(curStart, i);
        if(firstPart.length > 1) parts.push(firstPart);
        curStart = i - 1;
      }
    }
    const last = fullPath.slice(curStart);
    if(last.length > 1) parts.push(last);
    return parts;
  }

  function distanceOfPath(p){
    if(!p || p.length < 2) return 0;
    let d = 0;
    for(let i=0;i<p.length-1;i++){
      const a = p[i], b = p[i+1];
      if(typeof graph !== 'undefined' && graph && graph[a] && typeof graph[a][b] === 'number') d += graph[a][b];
      else if(typeof graph !== 'undefined' && graph && graph[b] && typeof graph[b][a] === 'number') d += graph[b][a];
      else d += 0;
    }
    return d;
  }

  const splitted = splitOnTripleRepeat(full);
  const outParts = splitted.map(p => ({ path: p, distance: distanceOfPath(p) }));
  return outParts;
}


function buildRoutePartsNoOverlapMinTransfers(from, viaStations, to){
  const waypoints = [from, ...viaStations, to];
  let full = [];
  let totalDist = 0;
  const used = new Set();

  for(let i=0;i<waypoints.length-1;i++){
    const a = waypoints[i], b = waypoints[i+1];
    const forbidden = new Set(used);
    if(forbidden.has(a)) forbidden.delete(a);
    if(forbidden.has(b)) forbidden.delete(b);

    const sp = shortestPathMinTransfers(a, b, forbidden);
    if(!sp.path || sp.path.length === 0){
      const sp2 = shortestPathAvoiding(a, b, forbidden);
      if(!sp2.path || sp2.path.length === 0){
        const sp3 = shortestPath(a, b);
        if(!sp3.path || sp3.path.length === 0) return null;
        const seg3 = (i===0) ? sp3.path.slice() : sp3.path.slice(1);
        full.push(...seg3);
        totalDist += sp3.distance;
        for(const st of sp3.path){ if(st !== b) used.add(st); }
        continue;
      } else {
        const seg2 = (i===0) ? sp2.path.slice() : sp2.path.slice(1);
        full.push(...seg2);
        totalDist += sp2.distance;
        for(const st of sp2.path){ if(st !== b) used.add(st); }
        continue;
      }
    }

    const seg = (i===0) ? sp.path.slice() : sp.path.slice(1);
    full.push(...seg);
    totalDist += sp.distance;
    for(const st of sp.path){ if(st !== b) used.add(st); }
  }

  if(full.length === 0) return [];

  function splitOnTripleRepeat(fullPath){
    if(!Array.isArray(fullPath) || fullPath.length === 0) return [fullPath.slice()];
    const parts = [];
    let curStart = 0;
    for(let i = 2; i < fullPath.length; i++){
      if(fullPath[i-2] === fullPath[i]){
        const firstPart = fullPath.slice(curStart, i);
        if(firstPart.length > 1) parts.push(firstPart);
        curStart = i - 1;
      }
    }
    const last = fullPath.slice(curStart);
    if(last.length > 1) parts.push(last);
    return parts;
  }

  function distanceOfPath(p){
    if(!p || p.length < 2) return 0;
    let d = 0;
    for(let i=0;i<p.length-1;i++){
      const a = p[i], b = p[i+1];
      if(typeof graph !== 'undefined' && graph && graph[a] && typeof graph[a][b] === 'number') d += graph[a][b];
      else if(typeof graph !== 'undefined' && graph && graph[b] && typeof graph[b][a] === 'number') d += graph[b][a];
      else d += 0;
    }
    return d;
  }

  const splitted = splitOnTripleRepeat(full);
  const outParts = splitted.map(p => ({ path: p, distance: distanceOfPath(p) }));
  return outParts;
}

/* ---- 以下は既存の分割・描画・運賃計算ロジックを保持 ---- */

function splitByCompany(path){
  if(path.length < 2) return [];
  let segments = [];
  let start = path[0];
  let prev = path[0];
  let curCompany = null;

  const firstLine = findLineOfSegment(path[0], path[1]);
  curCompany = firstLine ? companyFromLineName(firstLine) : null;

  for(let i=1;i<path.length;i++){
    const a = path[i-1], b = path[i];
    // 路線候補を取得
    const candidateLines = findLinesOfSegment(a,b);
    let ln = candidateLines.length ? candidateLines[0] : null;
    let comp = ln ? companyFromLineName(ln) : null;

    // 複数候補がある場合、現在の会社と一致する候補を優先
    if(candidateLines.length > 1 && curCompany){
      for(const cand of candidateLines){
        if(companyFromLineName(cand) === curCompany){
          ln = cand;
          comp = curCompany;
          break;
        }
      }
    }

    // 候補が見つからないが curCompany が既にある場合は継続扱い（不必要な分割を防ぐ）
    if(!comp && curCompany){
      comp = curCompany;
      ln = null;
    }

    if(comp !== curCompany){
      segments.push({ from:start, to:prev, company:curCompany });
      start = a;
      curCompany = comp;
    }
    prev = b;
  }
  segments.push({ from:start, to:prev, company:curCompany });
  return segments.filter(s => !!s.company && s.from !== s.to);
}

/* -----------------------------
   ここから描画周り（修正あり）
   - renderRouteCardForPart(part, partIndex, containerId)
   - IDs を containerId プレフィックス付きにして一意化
   - wireToggleButtons(containerId) を用いてコンテナ内のみバインド
   ----------------------------- */

function renderRouteCardForPart(part, partIndex, containerId){
  const path = part.path;

  const { majors } = majorStops(path);

  const majorIndices = [];
  let scanStart = 0;
  for(let m = 0; m < majors.length; m++){
    const mi = findIndexFrom(path, majors[m], scanStart);
    if(mi === -1){
      majorIndices.push(path.indexOf(majors[m]));
      scanStart = (majorIndices[majorIndices.length-1] >= 0) ? majorIndices[majorIndices.length-1] + 1 : scanStart+1;
    } else {
      majorIndices.push(mi);
      scanStart = mi + 1;
    }
  }

  const majorsColors = new Array(majors.length).fill("#999");

  for(let idx = 0; idx < majors.length; idx++){
    const st = majors[idx];
    const nextStation = idx < majors.length - 1 ? majors[idx+1] : null;

    let color = "#999";

    const iFrom = majorIndices[idx];
    const iTo = (nextStation !== null) ? majorIndices[idx+1] : -1;

    if(nextStation && iFrom !== -1 && iTo !== -1){
      const usedLines = [];
      const usedPairs = [];
      for(let i=iFrom;i<iTo;i++){
        const ln = findLineOfSegment(path[i], path[i+1]);
        usedPairs.push({pair:[path[i], path[i+1]], line:ln, idx:i});
        if(ln && usedLines.indexOf(ln)===-1) usedLines.push(ln);
      }

      const topPair = usedPairs.find(p=>p.idx===iFrom && p.line);
      if(topPair && topPair.line){
        const comp = companyFromLineName(topPair.line);
        // 鉄道会社リストに完全一致するなら既存の lineColors を優先
        if(railwayCompanyList.includes(comp)){
          if(lineColors[topPair.line]) color = lineColors[topPair.line];
        } else if(busCompanyList.includes(comp)){
          // バス会社として描画（グレーを使う）
          color = '#aaaaaa';
        } else if(lineColors[topPair.line]){
          color = lineColors[topPair.line];
        }
      } else {
        // フォールバック: usedLines を順に確認して鉄道会社/バス会社の順で振り分ける
        for(const ln of usedLines){
          const comp = companyFromLineName(ln);
          if(railwayCompanyList.includes(comp) && lineColors[ln]){ color = lineColors[ln]; break; }
          if(busCompanyList.includes(comp)){ color = '#aaaaaa'; break; }
          if(lineColors[ln]){ color = lineColors[ln]; break; }
        }
      }
} else if(!nextStation){
      if(iFrom > 0){
        const ln = findLineOfSegment(path[iFrom-1], path[iFrom]);
        if(ln && lineColors[ln]) color = lineColors[ln];
      } else if(path.length >= 2){
        const ln0 = findLineOfSegment(path[0], path[1]);
        if(ln0 && lineColors[ln0]) color = lineColors[ln0];
      }
    } else {
      if(path.length >= 2){
        const ln0 = findLineOfSegment(path[0], path[1]);
        if(ln0 && lineColors[ln0]) color = lineColors[ln0];
      }
    }

    majorsColors[idx] = color;
  }

  // container-scoped IDs: prefix with containerId
  const cid = containerId;

  let routeHtml = `
    <div class="card">
      <div class="resultHeader">
        <div class="meta"></div>
      </div>
      <div class="routeLine">
  `;

  for(let idx = 0; idx < majors.length; idx++){
    const st = majors[idx];
    const nextStation = idx < majors.length - 1 ? majors[idx+1] : null;

    const iFrom = majorIndices[idx];
    const iTo = (nextStation !== null) ? majorIndices[idx+1] : -1;

    const color = majorsColors[idx];
    const nextColor = nextStation ? majorsColors[idx+1] : null;

    let lineListHtml = '';

    let usedLinesForSegment = [];
    if(nextStation && iFrom !== -1 && iTo !== -1){
      for(let i=iFrom;i<iTo;i++){
        const ln = findLineOfSegment(path[i], path[i+1]);
        if(ln && !usedLinesForSegment.includes(ln)) usedLinesForSegment.push(ln);
      }
      const badges = usedLinesForSegment.length > 0 ? usedLinesForSegment : findCommonLines(st, nextStation);
      if(badges.length > 0){
        lineListHtml = badges.map(l => `<div class="lineBadge" style="background:${lineColors[l] || '#999'};color:#fff">${l}</div>`).join('');
      }
    } else if(!nextStation){
      lineListHtml = '';
    }

    const bigLineId = `${cid}-part${partIndex}-bigline-${idx}`;
    const betweenId = `${cid}-part${partIndex}-between-${idx}`;

    let initialStyle = '';
    if(nextStation){
      if(usedLinesForSegment.length > 0){
        if(usedLinesForSegment.length === 1){
          initialStyle = `background: ${lineColors[usedLinesForSegment[0]] || color};`;
        } else {
          const step = 100 / usedLinesForSegment.length;
          const stops = usedLinesForSegment.map((ln, j) => {
            const col = lineColors[ln] || '#999';
            const start = (j * step).toFixed(4);
            const end = ((j+1) * step).toFixed(4);
            return `${col} ${start}%, ${col} ${end}%`;
          }).join(', ');
          initialStyle = `background: linear-gradient(to bottom, ${stops});`;
        }
      } else {
        if(nextColor && nextColor !== color){
          initialStyle = `background: linear-gradient(to bottom, ${color}, ${nextColor});`;
        } else {
          initialStyle = `background: ${color};`;
        }
      }
    } else {
      initialStyle = `background: ${color};`;
    }

    const usedLinesDataAttr = usedLinesForSegment.join('|');
    const isWalkSegment = usedLinesForSegment && usedLinesForSegment.some(l=>/徒歩/.test(l));
    let walkMeters = 0, walkMinutes = 0;
    if(isWalkSegment){
      for(let ii=iFrom; ii<iTo; ii++){
        const a = path[ii], b = path[ii+1];
        let d = 0;
        if(graph[a] && typeof graph[a][b] === 'number') d = graph[a][b];
        else if(graph[b] && typeof graph[b][a] === 'number') d = graph[b][a];
        walkMeters += d * 1000;
      }
      walkMeters = Math.round(walkMeters);
      walkMinutes = Math.ceil(walkMeters / 80) || 1;
    }


    routeHtml += `
      <div class="rowStation">
        <div class="railCol">
          <div class="railDot" style="background:${color}"></div>
          ${nextStation ? `<div id="${bigLineId}" class="railLineMajor" data-color="${color}" data-nextcolor="${nextColor || color}" data-usedlines="${usedLinesDataAttr}" style="${initialStyle}"></div>${ (usedLinesForSegment && usedLinesForSegment.some(l=>/バス/.test(l))) ? `<div id="${bigLineId}-overlay" class="busOverlay"></div>` : '' }` : `<div class="spacer6"></div>`}
        </div>
        <div class="stationText">
          <div class="stationName">${displayStationName(st)}</div>
          ${ isWalkSegment ? '' : lineListHtml }
          ${nextStation ? `${nextStation ? '<div class="toggleWrap">' + (isWalkSegment ? ('徒歩乗換 ' + walkMeters + 'm（所要時間約' + walkMinutes + '分）') : ('<button class="toggleBtn" data-container="' + cid + '" data-part="' + partIndex + '" data-seg="' + idx + '" data-open="false" data-usedlines="' + usedLinesDataAttr + '">' + (usedLinesForSegment && usedLinesForSegment.some(l=>/バス/.test(l)) ? '経由地を表示' : '停車駅を表示') + '</button>')) + '</div>' : ''}` : ''}
        </div>
      </div>
    `;

    if(nextStation && iFrom !== -1 && iTo !== -1){
      if(iTo - iFrom > 1){
        const betweenStart = iFrom + 1;
        const betweenEnd = iTo - 1;
        const betweenCount = betweenEnd - betweenStart + 1;
        const pairColors = new Array(Math.max(0, betweenCount)).fill('#999');
        const pairUsedLines = new Array(Math.max(0, betweenCount)).fill('');
        const isCondArr = new Array(Math.max(0, betweenCount)).fill(false);

        for(let bj = betweenStart; bj <= betweenEnd; bj++){
          const jIndex = bj;
          const s = path[jIndex];
          let isCondMinor = false;
          const condsAll = connectingStations.filter(c => c.station === s);
          let conds = [];
          if(condsAll && condsAll.length > 0){
            conds = condsAll;
          }
          if(conds && conds.length > 0){
            const idxS = jIndex;
            for(const cond of conds){
              const idxsA = indexesOf(path, cond.endpoints[0]);
              const idxsB = indexesOf(path, cond.endpoints[1]);
              if(idxsA.length > 0 && idxsB.length > 0){
                outer3: for(const ia of idxsA){
                  for(const ib of idxsB){
                    if(betweenExclusive(idxS, ia, ib)){ isCondMinor = true; break outer3; }
                  }
                }
                if(isCondMinor) break;
              }
            }
          }
          isCondArr[bj - betweenStart] = isCondMinor;

          const prevSt = path[jIndex-1];
          const nextSt = path[jIndex+1];

          const directCandidates = findLinesOfSegment(s, nextSt);
          if(directCandidates.length > 0){
            let chosen = null;
            for(const ln of directCandidates){
              if(lineColors[ln]){ chosen = ln; break; }
            }
            if(chosen){
              pairColors[bj - betweenStart] = lineColors[chosen]; pairUsedLines[bj - betweenStart] = chosen;
              continue;
            }
          }

          let threeLine = null;
          for(const [ln, stations] of Object.entries(stationLines)){
            if(stations.indexOf(prevSt) !== -1 && stations.indexOf(s) !== -1 && stations.indexOf(nextSt) !== -1){
              threeLine = ln;
              break;
            }
          }
          if(threeLine && lineColors[threeLine]){
            pairColors[bj - betweenStart] = lineColors[threeLine]; pairUsedLines[bj - betweenStart] = threeLine;
            continue;
          }

          let bothLine = null;
          for(const [ln, stations] of Object.entries(stationLines)){
            if(stations.indexOf(prevSt) !== -1 && stations.indexOf(nextSt) !== -1){
              bothLine = ln;
              break;
            }
          }
          if(bothLine && lineColors[bothLine]){
            pairColors[bj - betweenStart] = lineColors[bothLine]; pairUsedLines[bj - betweenStart] = bothLine;
            continue;
          }

          const adjPairs = [];
          if(jIndex > 0) adjPairs.push([path[jIndex-1], path[jIndex]]);
          if(jIndex < path.length - 1) adjPairs.push([path[jIndex], path[jIndex+1]]);
          for(const p of adjPairs){
            const ln = findLineOfSegment(p[0], p[1]);
            if(ln && lineColors[ln]){ pairColors[bj - betweenStart] = lineColors[ln]; pairUsedLines[bj - betweenStart] = ln; break; }
          }
        }

        routeHtml += `<div id="${betweenId}" class="betweenList">`;
        for(let bj = betweenStart; bj <= betweenEnd; bj++){
          const s = path[bj];
          const arrIdx = bj - betweenStart;
          const isCondMinor = isCondArr[arrIdx];
          const minorClass = isCondMinor ? 'condMinorName' : 'minorName';
          let displayColor = pairColors[arrIdx];
          if(isCondMinor){
            const nextArrIdx = arrIdx + 1;
            if(nextArrIdx < pairColors.length){
              displayColor = pairColors[nextArrIdx];
            } else {
              displayColor = pairColors[arrIdx];
            }
          }

          
          routeHtml += `
            <div class="rowBetween">
              <div class="railCol">
                <div class="railDot" style="background:${displayColor}"></div>
                <div id="${betweenId}-minorLine-${arrIdx}" class="railLineMinor" data-usedlines="${pairUsedLines[arrIdx]||''}" style="${ (pairUsedLines[arrIdx] && /徒歩/.test(pairUsedLines[arrIdx])) ? 'background: repeating-linear-gradient(  to bottom,  #aaa 0px,  #aaa 8px, #fff 8px,  #fff 16px);' : 'background:'+displayColor+';' }"></div>
                ${ (pairUsedLines[arrIdx] && /バス/.test(pairUsedLines[arrIdx])) ? `<div id="${betweenId}-overlay-${arrIdx}" class="busOverlay"></div>` : '' }
              </div>
              <div class="stationText"><div class="${minorClass}">${displayStationName(s)}</div></div>
            </div>
          `;
}
        routeHtml += `</div>`;
      }
    }
  }

  routeHtml += `</div></div>`;
  return routeHtml;
}

// containerId を受け取って、そのコンテナ内の .toggleBtn のみにリスナをバインドする





function wireToggleButtons(containerId){
  refreshTabButtons();
  tabButtons.forEach(btn=>{
    if(btn._tabListener) btn.removeEventListener('click', btn._tabListener);
    const listener = ()=>{
      const target = btn.dataset.target;
      tabButtons.forEach(b=>b.classList.remove('active'));
      btn.classList.add('active');
      if(target === 'shortest'){
        const elS = document.getElementById('result-shortest');
        const elF = document.getElementById('result-fewest');
        if(elS) elS.style.display = 'block';
        if(elF) elF.style.display = 'none';
      } else {
        const elS = document.getElementById('result-shortest');
        const elF = document.getElementById('result-fewest');
        if(elS) elS.style.display = 'none';
        if(elF) elF.style.display = 'block';
      }
      runAdjustments();
    };
    btn.addEventListener('click', listener);
    btn._tabListener = listener;
  });

  function readableTextColor(hex){
    if(!hex) return '#fff';
    let r=0,g=0,b=0;
    if(hex.startsWith('rgb')){
      const nums = hex.replace(/[^\d,]/g,'').split(',').map(n=>parseInt(n,10));
      [r,g,b] = nums;
    } else {
      const h = hex.replace('#','');
      if(h.length === 3){
        r = parseInt(h[0]+h[0],16);
        g = parseInt(h[1]+h[1],16);
        b = parseInt(h[2]+h[2],16);
      } else {
        r = parseInt(h.substr(0,2),16);
        g = parseInt(h.substr(2,2),16);
        b = parseInt(h.substr(4,2),16);
      }
    }
    const luminance = (0.299*r + 0.587*g + 0.114*b)/255;
    return luminance > 0.6 ? '#111' : '#fff';
  }

  // Reposition a specific between-count so it's horizontally centered with the line
  // and vertically located at the midpoint between the BOTTOM of the start major dot and
  // the TOP of the end major dot (this keeps the label visually centered between the two dots).
  function positionLabelOverLine(span, bigLine){
    try{
      if(!bigLine || !span) return;
      // railCol is the parent of bigLine; its containing row is the .rowStation element
      const railCol = bigLine.parentElement;
      if(!railCol) return;
      const row = railCol.closest('.rowStation') || railCol.parentElement;
      if(!row) return;
      // find next visible rowStation that contains a .railDot
      const rows = Array.from(row.parentElement.querySelectorAll('.rowStation'));
      const idx = rows.indexOf(row);
      let nextRow = null;
      for(let i = idx + 1; i < rows.length; i++){
        const r = rows[i];
        if(r && r.offsetParent && r.querySelector('.railDot')){ nextRow = r; break; }
      }
      // If nextRow not found, fallback to center of bigLine bounding box
      const parent = railCol;
      if(getComputedStyle(parent).position === 'static'){
        parent.style.position = 'relative';
      }
      const parentRect = parent.getBoundingClientRect();
      const spanRect = span.getBoundingClientRect();
      const startDot = row.querySelector('.railDot');
      const endDot = nextRow ? nextRow.querySelector('.railDot') : null;
      if(startDot && endDot){
        const startRect = startDot.getBoundingClientRect();
        const endRect = endDot.getBoundingClientRect();
        // compute midpoint between bottom of start dot and top of end dot (relative to parent)
        const startBottomRel = startRect.bottom - parentRect.top;
        const endTopRel = endRect.top - parentRect.top;
        const centerY = (startBottomRel + endTopRel) / 2;
        // horizontal centering: keep label at 50% of parent (line is centered there)
        span.style.left = '50%';
        span.style.transform = 'translateX(-50%)';
        const topPx = Math.round(centerY - spanRect.height / 2);
        span.style.top = Math.max(2, topPx) + 'px';
      } else {
        // fallback: use bigLine bounding box center (previous behavior) if we can't find next dot
        const lineRect = bigLine.getBoundingClientRect();
        const centerY = (lineRect.top - parentRect.top) + (lineRect.height / 2);
        span.style.left = '50%';
        span.style.transform = 'translateX(-50%)';
        const topPx = Math.round(centerY - spanRect.height / 2);
        span.style.top = Math.max(2, topPx) + 'px';
      }
    }catch(e){
      // if anything goes wrong, silently ignore to avoid breaking UI
      return;
    }
  }

  function updateBetweenCount(list, bigLine, cid, part, idx){
    if(!bigLine) return;
    const countId = `${cid}-part${part}-bigline-${idx}-between-count`;
    const existing = document.getElementById(countId);
    const rows = list ? list.querySelectorAll('.rowBetween').length : 0;
    const isHidden = list ? (getComputedStyle(list).display === 'none') : true;
    if(rows >= 1 && isHidden){
      if(!existing){
        const parent = bigLine.parentElement;
        if(parent && getComputedStyle(parent).position === 'static'){
          parent.style.position = 'relative';
        }
        const span = document.createElement('span');
        span.id = countId;
        span.className = 'between-count';
        span.textContent = rows.toString() + '駅';
        span.style.position = 'absolute';
        span.style.pointerEvents = 'auto';
        span.style.fontSize = '11px';
        span.style.padding = '1px 6px';
        span.style.borderRadius = '999px';
        span.style.whiteSpace = 'nowrap';
        span.style.fontWeight = '700';
        span.style.zIndex = '9999';
        span.style.border = '1px solid #fff';
        const baseColor = (bigLine.dataset && bigLine.dataset.color) ? bigLine.dataset.color : '#f5a623';
        span.dataset.bg = baseColor;
        span.style.background = baseColor;
        span.style.color = readableTextColor(baseColor);
        span.style.boxShadow = '0 1px 2px rgba(0,0,0,0.06)';
        parent.appendChild(span);
        // Ensure layout happened, then position precisely at the center of the line
        // Use requestAnimationFrame to ensure correct measurements after insertion
        requestAnimationFrame(()=>{ positionLabelOverLine(span, bigLine); });
      } else {
        existing.textContent = rows.toString() + '駅';
        const baseColor = (bigLine.dataset && bigLine.dataset.color) ? bigLine.dataset.color : '#f5a623';
        existing.style.background = baseColor;
        existing.style.color = readableTextColor(baseColor);
        // reposition to always be centered vertically/horizontally
        requestAnimationFrame(()=>{ positionLabelOverLine(existing, bigLine); });
      }
    } else {
      if(existing){
        existing.remove();
      }
    }
  }

  // Reposition all between-count labels (useful on resize/scroll/runAdjustments)
  function repositionAllBetweenCounts(){
    const labels = Array.from(document.querySelectorAll('.between-count'));
    labels.forEach(label=>{
      // derive bigLine id from label id pattern: <cid>-part<part>-bigline-<idx>-between-count
      const id = label.id || '';
      const m = id.match(/^(.*-bigline-(\d+))-between-count$/);
      if(!m) return;
      const bigLineIdBase = m[1]; // e.g., result-shortest-part0-bigline-1
      const bigLine = document.getElementById(bigLineIdBase);
      if(bigLine){
        positionLabelOverLine(label, bigLine);
      }
    });
  }

  // keep labels aligned on resize/scroll/orientationchange
  if(!window._betweenCountListenersAdded){
    const reposition = ()=>{ requestAnimationFrame(repositionAllBetweenCounts); };
    window.addEventListener('resize', reposition);
    window.addEventListener('scroll', reposition, true);
    window.addEventListener('orientationchange', reposition);
    // Hook into runAdjustments if available by wrapping it to also reposition (if runAdjustments exists)
    if(typeof runAdjustments === 'function'){
      const origRunAdjustments = runAdjustments;
      runAdjustments = function(){
        const res = origRunAdjustments.apply(this, arguments);
        requestAnimationFrame(repositionAllBetweenCounts);
        return res;
      };
    }
    window._betweenCountListenersAdded = true;
  }

  const containers = ['result-shortest','result-fewest'];
  containers.forEach(containerIdLocal=>{
    const container = document.getElementById(containerIdLocal);
    if(!container) return;
    const toggleBtns = Array.from(container.querySelectorAll('.toggleBtn'));
    toggleBtns.forEach(btn=>{
      if(btn._routeToggleListener) btn.removeEventListener('click', btn._routeToggleListener);

      const part = btn.dataset.part;
      const idx = btn.dataset.seg;
      const cid = btn.dataset.container || containerIdLocal;
      const listId = `${cid}-part${part}-between-${idx}`;
      const list = document.getElementById(listId);

      if(!list || list.querySelectorAll('.rowBetween').length === 0){
        btn.style.display = 'none';
        const bigLineId = `${cid}-part${part}-bigline-${idx}`;
        const bigLine = document.getElementById(bigLineId);
        if(bigLine){
          const countEl = document.getElementById(`${bigLineId}-between-count`);
          if(countEl) countEl.remove();
        }
        return;
      } else {
        btn.style.display = '';
      }

      const bigLineId = `${cid}-part${part}-bigline-${idx}`;
      const bigLine = document.getElementById(bigLineId);
      updateBetweenCount(list, bigLine, cid, part, idx);

      const listener = ()=>{
        const part = btn.dataset.part;
        const idx = btn.dataset.seg;
        const cid = btn.dataset.container || containerIdLocal;
        const listId = `${cid}-part${part}-between-${idx}`;
        const bigLineId = `${cid}-part${part}-bigline-${idx}`;
        const list = document.getElementById(listId);
        const bigLine = document.getElementById(bigLineId);
        if(!list) return;
        const isOpen = getComputedStyle(list).display !== 'block';
        list.style.display = isOpen ? 'block' : 'none';
        btn.dataset.open = isOpen.toString();
        const usedLinesRaw = btn.dataset.usedlines || '';
        const isBus = /バス/.test(usedLinesRaw);
        btn.textContent = isOpen ? (isBus ? '経由地を非表示' : '停車駅を非表示') : (isBus ? '経由地を表示' : '停車駅を表示');

        if(bigLine){
          const baseColor = bigLine.dataset.color || '#999';

          if(isOpen){
            bigLine.style.background = baseColor;
            shortenBigLineToFirstBetween(bigLine, list);
          } else {
            delete bigLine.dataset.shortened;
            runAdjustments();
          }
        }

        updateBetweenCount(list, bigLine, cid, part, idx);

        runAdjustments();
      };
      btn.addEventListener('click', listener);
      btn._routeToggleListener = listener;
    });
  });
}
function shortenBigLineToFirstBetween(bigLine, betweenEl){
  if(!bigLine || !betweenEl) return;
  const railCol = bigLine.parentElement;
  if(!railCol) return;
  const parentRect = railCol.getBoundingClientRect();
  const dot = railCol.querySelector('.railDot');
  if(!dot) return;
  const dotRect = dot.getBoundingClientRect();
  const firstBetweenRow = betweenEl.querySelector('.rowBetween');
  if(!firstBetweenRow) return;
  const betweenDot = firstBetweenRow.querySelector('.railDot');
  if(!betweenDot) return;
  const betweenDotRect = betweenDot.getBoundingClientRect();
  const newTop = dotRect.top - parentRect.top;
  const newHeight = Math.max(0, (betweenDotRect.top - dotRect.top)) + 2;
  bigLine.style.top = newTop + 'px';
  bigLine.style.height = newHeight + 'px';
  bigLine.dataset.shortened = "true";
}

/* ===========================
   検索イベント、レンダリング
   =========================== */


// --- 追加ヘルパー: 乗換回数計算と fewest 用ソート ---
function computeTransferCountForPart(part){
  if(!part || !part.path) return Infinity;
  const comps = splitByCompany(part.path);
  if(!comps || comps.length === 0) return 0;
  let transferCount = 0;
  for(let i=1;i<comps.length;i++){
    if(comps[i-1].company !== comps[i].company) transferCount++;
  }
  return transferCount;
}

function sortPartsForFewest(parts){
  if(!Array.isArray(parts)) return parts;
  return parts.slice().sort((A,B)=>{
    const tA = computeTransferCountForPart(A);
    const tB = computeTransferCountForPart(B);
    if(tA !== tB) return tA - tB;
    if(A.distance !== B.distance) return A.distance - B.distance;
    const mA = (A.majors?A.majors.length:0);
    const mB = (B.majors?B.majors.length:0);
    return mA - mB;
  });
}

function getActiveTab(){
  const btn = document.querySelector('.tabBtn.active');
  return btn ? btn.dataset.target : 'shortest';
}
// --- ヘルパーここまで ---
function renderResultHeader(totalDistance, totalFare){
  return `
    <div class="card">
      <div class="resultHeader">
        <div style="font-weight:800">検索結果</div>
        <div class="meta">
          <div>合計距離: <strong>${totalDistance.toFixed(1)} km</strong></div>
          <div>合計運賃: <strong>${totalFare} 円</strong></div>
        </div>
      </div>
    </div>
  `;
}

// 共通レンダラ（parts をそのまま描画）
// containerId を指定して描画 -> 生成される要素 ID は containerId をプレフィックスとして一意化する
function renderRoutesIntoContainer(parts, containerId){
  // ensure container exists
  let container = document.getElementById(containerId);
  if(!container){
    // create container inside resultArea to preserve structure
    container = document.createElement('div');
    container.id = containerId;
    if(containerId === 'result-fewest') container.style.display = 'none';
    resultArea.appendChild(container);
  }

  if(!parts || parts.length === 0){
    container.innerHTML = '<div class="card">経路が見つかりませんでした。</div>';
    return;
  }

  const totalDistance = parts.reduce((acc,p)=>acc+p.distance, 0);

  const allCompanySegments = [];
  for(const part of parts){
    const comps = splitByCompany(part.path);
    for(const c of comps) allCompanySegments.push(c);
  }

  let totalFare = 0;

  // --- TOゾーン定義: 東橋本線の東橋から新東橋の各駅 + 東橋鉄道横宿線の全区間 ---
  function buildTOZoneSet(){
    const set = new Set();
    const mainLine = stationLines['東橋鉄道東橋本線'] || [];
    const yokoLine = stationLines['東橋鉄道横宿線'] || [];

    const idxFrom = mainLine.indexOf('東橋');
    const idxTo = mainLine.indexOf('新東橋');
    if(idxFrom !== -1 && idxTo !== -1){
      const a = Math.min(idxFrom, idxTo), b = Math.max(idxFrom, idxTo);
      for(let i=a;i<=b;i++) set.add(mainLine[i]);
    }
    // 横宿線は全区間を追加
    for(const s of yokoLine) set.add(s);
    return set;
  }
  const TO_ZONE_SET = buildTOZoneSet();
  function isInTOZone(st){
    return TO_ZONE_SET.has(st);
  }

  // --- 各社ごとの区間運賃を計算（TOゾーン均一と園木割引を適用） ---
  for(let i=0;i<allCompanySegments.length;i++){
    const seg = allCompanySegments[i];
    const spComp = shortestPathWithinCompany(seg.from, seg.to, seg.company);
    let segFare = 0;

    // TOゾーン内発着なら250円均一（会社問わずその区間が全てTOゾーン内発着であること）
    if(isInTOZone(seg.from) && isInTOZone(seg.to)){
      segFare = 250;
    } else {
      // shortestPathWithinCompany が見つからない（会社別経路が disconnected）の場合は
      // 全体の最短経路距離で代替する（不当に大きな既定料金が適用されるのを防ぐ）
      if(!isFinite(spComp.distance)){
        console.warn('company-constrained path not found for', seg, 'falling back to overall shortest path');
        const spAny = shortestPath(seg.from, seg.to);
        segFare = fareByCompany(seg.company, spAny.distance);
      } else {
        segFare = fareByCompany(seg.company, spComp.distance);
      }
    }

    // 東橋鉄道→園木→他社線 の場合、その東橋鉄道区間は50円引き
    if(seg.company === '東橋鉄道' && seg.to === '園木'){
      const nextSeg = allCompanySegments[i+1];
      if(nextSeg && nextSeg.company && nextSeg.company == '豊野鉄道'){
        segFare = Math.max(0, segFare - 50);
      }
    }

    totalFare += segFare;
  }


  // 運賃特例：五社（新里・豊野・桜川・大桑・笠原）のみを対象に乗換回数×100円を割引する
  const eligibleCompanies = new Set(["新里鉄道","豊野鉄道","桜川電気鉄道","大桑鉄道","笠原電気鉄道"]);
  const usedCompaniesSet = new Set(allCompanySegments.map(s => s.company).filter(Boolean));

  // --- 徒歩連絡（徒歩乗換）が経路内に含まれるか判定 ---
  function pathHasWalk(parts){
    if(!Array.isArray(parts)) return false;
    for(const part of parts){
      const path = part.path || [];
      for(let i=1;i<path.length;i++){
        const a = path[i-1], b = path[i];
        // 1) 路線定義上に「徒歩」を含む路線があれば徒歩あり
        const candidateLines = findLinesOfSegment(a,b) || [];
        if(candidateLines.some(l => /徒歩/.test(l))) return true;
        // 2) 明示的に stationLines['徒歩乗換'] に登録されている隣接なら徒歩
        const walkList = stationLines['徒歩乗換'] || [];
        const ia = walkList.indexOf(a), ib = walkList.indexOf(b);
        if(ia !== -1 && ib !== -1 && Math.abs(ia - ib) === 1) return true;
        // 3) 候補路線が無く、距離が非常に短ければ徒歩と推定（例: 0.5km 以下）
        if(candidateLines.length === 0 && graph[a] && typeof graph[a][b] === 'number' && graph[a][b] <= 0.5) return true;
      }
    }
    return false;
  }

  const hasWalk = pathHasWalk(parts);

  // 特例適用フラグ（五社のみで構成されていることが前提）
  let applyDiscount = true;
  if(usedCompaniesSet.size === 0) applyDiscount = false;
  for(const c of usedCompaniesSet){
    if(!eligibleCompanies.has(c)){ applyDiscount = false; break; }
  }
  // 「間に徒歩連絡を挟むとき」は特例の適用外
  if(hasWalk) applyDiscount = false;

  if(applyDiscount){
    let transferCount = 0;
    for(let i=1;i<allCompanySegments.length;i++){
      const prev = allCompanySegments[i-1].company;
      const cur = allCompanySegments[i].company;
      if(prev !== cur) transferCount++;
    }
    const discount = transferCount * 100;
    totalFare = Math.max(0, totalFare - discount);
  }

const headerHtml = renderResultHeader(totalDistance, totalFare);

  let html = headerHtml;
  // fewest タブでは乗り換え回数を最優先でソート
  const activeTab = getActiveTab();
  const partsToRender = (activeTab === 'fewest') ? sortPartsForFewest(parts) : parts;
  partsToRender.forEach((p, idx)=>{
    html += renderRouteCardForPart(p, idx, containerId);
  });

  container.innerHTML = html;

  // container 内のトグルボタンだけにリスナをバインド（ID 重複の影響を排除）
  wireToggleButtons(containerId);

  // 可視なら runAdjustments（非表示なら skip。タブ切替で runAdjustments を呼ぶ）
  if(container.offsetParent) runAdjustments();
}

searchBtn.addEventListener('click', ()=>{
  // 発/着/経由の stationSelect をまとめて探す（DOM上の順に依存）
  const stationSelectsAll = Array.from(document.querySelectorAll('.stationSelect'));
  const from = stationSelectsAll[0] ? stationSelectsAll[0].value : '';
  const to = stationSelectsAll[stationSelectsAll.length - 1] ? stationSelectsAll[stationSelectsAll.length - 1].value : '';
  const viaSelects = Array.from(viaListDiv.querySelectorAll('.stationSelect'));
  const viaStations = viaSelects.map(s=>s.value).filter(v=>v);

  // ensure result containers exist to avoid accidentally wiping structure
  if(!document.getElementById('result-shortest') || !document.getElementById('result-fewest')){
    resultArea.innerHTML = '<div id="result-shortest"></div><div id="result-fewest" style="display:none"></div>';
  }

  if(!from || !to){
    document.getElementById('result-shortest').innerHTML = '<div class="card">駅を選択してください</div>';
    document.getElementById('result-fewest').innerHTML = '';
    resultTabs.style.display = 'none';
    refreshTabButtons();
    return;
  }
  if(from === to && viaStations.length === 0){
    document.getElementById('result-shortest').innerHTML = '<div class="card">発駅と着駅が同じです</div>';
    document.getElementById('result-fewest').innerHTML = '';
    resultTabs.style.display = 'none';
    refreshTabButtons();
    return;
  }

  // 保存
  saveSelections();

  // 距離優先（既存のロジック）
  const partsShortest = buildRoutePartsNoOverlap(from, viaStations, to);
  // 乗換少なめ（主要駅数を最優先で最小化；接続駅は主要駅カウントから除外）
  const partsFewest = buildRoutePartsNoOverlapMinTransfers(from, viaStations, to);

  if((!partsShortest || partsShortest.length === 0) && (!partsFewest || partsFewest.length === 0)){
    document.getElementById('result-shortest').innerHTML = '<div class="card">経路が見つかりませんでした。</div>';
    document.getElementById('result-fewest').innerHTML = '';
    resultTabs.style.display = 'none';
    refreshTabButtons();
    return;
  }

  // タブを表示
  resultTabs.style.display = 'flex';
  refreshTabButtons();

  // 描画（それぞれ別コンテナに）
  renderRoutesIntoContainer(partsShortest || [], 'result-shortest');
  renderRoutesIntoContainer(partsFewest || [], 'result-fewest');

  // タブ制御: 距離短いをデフォルトで表示
  tabButtons.forEach(btn=> btn.classList.remove('active'));
  const shortestBtn = resultTabs.querySelector('[data-target="shortest"]');
  if(shortestBtn) shortestBtn.classList.add('active');
  document.getElementById('result-shortest').style.display = 'block';
  document.getElementById('result-fewest').style.display = 'none';
  runAdjustments();
});

// タブ押下で切り替え
function wireTabButtons(){
  refreshTabButtons();
  tabButtons.forEach(btn=>{
    // remove previous to avoid double-binding
    if(btn._tabListener) btn.removeEventListener('click', btn._tabListener);
    const listener = ()=>{
      const target = btn.dataset.target;
      tabButtons.forEach(b=>b.classList.remove('active'));
      btn.classList.add('active');
      if(target === 'shortest'){
        const elS = document.getElementById('result-shortest');
        const elF = document.getElementById('result-fewest');
        if(elS) elS.style.display = 'block';
        if(elF) elF.style.display = 'none';
      } else {
        const elS = document.getElementById('result-shortest');
        const elF = document.getElementById('result-fewest');
        if(elS) elS.style.display = 'none';
        if(elF) elF.style.display = 'block';
      }
      // 表示切替後に再調整（非表示時の計算を避ける）
      runAdjustments();
    };
    btn.addEventListener('click', listener);
    btn._tabListener = listener;
  });
}
wireTabButtons();

/* EOF */

// --- 徒歩乗換の開始駅の丸の色を前の駅と同じにする ---
function colorWalkTransferStartDots() {
  const rows = Array.from(document.querySelectorAll('.rowStation'));
  for (let i = 1; i < rows.length; i++) {
    const row = rows[i];
    const railCol = row.querySelector('.railCol');
    const dot = railCol ? railCol.querySelector('.railDot') : null;
    const lineElem = railCol ? railCol.querySelector('.railLineMajor') : null;
    if (!dot || !lineElem) continue;

    if (lineElem.dataset.usedlines && lineElem.dataset.usedlines.includes('徒歩乗換')) {
      const prevRow = rows[i - 1];
      if (!prevRow) continue;
      const prevLine = prevRow.querySelector('.railLineMajor');
      if (prevLine && prevLine.dataset.usedlines) {
        const prevLines = prevLine.dataset.usedlines.split('|').filter(x => x && x !== '徒歩乗換');
        if (prevLines.length > 0) {
          const prevColor = lineColors[prevLines[prevLines.length - 1]] || '#aaa';
          dot.style.background = prevColor;
        }
      }
    }
  }
}

</script>

<!-- Search logging script: sends search events to provided Google Apps Script Web App -->
<script id="search-logging">
const GAS_ENDPOINT = "https://script.google.com/macros/s/AKfycbwjbJpATKXg9FAC0yQctmeRLK2FwF3leMBg_wjBpck5G61WUibaAOVgLHXpIN2bba_5/exec";

function collectSearchPayload(){
  try{
    const fromEl = document.getElementById("fromStation") || document.querySelector("#fromStation");
    const toEl = document.getElementById("toStation") || document.querySelector("#toStation");
    const from = fromEl ? (fromEl.value ?? fromEl.textContent ?? "") : "";
    const to = toEl ? (toEl.value ?? toEl.textContent ?? "") : "";
    const viaElems = document.querySelectorAll(".viaRow select, .viaRow input");
    const via = Array.from(viaElems).map(e => e.value || e.textContent || "").filter(x => x);
    return {
      from: from,
      via: via,
      to: to,
      time: new Date().toISOString(),
      userAgent: navigator.userAgent
    };
  }catch(e){
    return {error: e.message, time: new Date().toISOString()};
  }
}

function sendLogToGAS(payload){
  if(!GAS_ENDPOINT || GAS_ENDPOINT.includes("PASTE_YOUR_GAS_WEBAPP_URL_HERE")){
    console.info("GAS endpoint not set.");
    return;
  }
  fetch(GAS_ENDPOINT, {
    method: "POST",
    mode: "cors",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify(payload)
  }).then(response=>{
    console.info("search log sent", response.status);
  }).catch(err=>{
    console.warn("failed to send search log", err);
  });
}

document.addEventListener("DOMContentLoaded", function(){
  const btn = document.getElementById("searchBtn");
  if(!btn){
    console.warn("searchBtn not found; logging won't run.");
    return;
  }
  btn.addEventListener("click", function(){
    const payload = collectSearchPayload();
    sendLogToGAS(payload);
  }, {passive:true});
});
</script>

</body>
</html>
