<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>新里鉄道路線 ルート検索</title>
  <style>
    :root{
      --major-r: 10px;      /* 主要駅 ● 半径 */
      --minor-r: 7.5px;     /* 途中駅 ● 半径（主要の75%） */
      --seg-width: 6px;     /* 区間線の太さ */
    }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, 'Hiragino Kaku Gothic ProN', 'Noto Sans JP', Meiryo, sans-serif; margin: 18px; }
    h1 { font-size: 50px; margin: 0 0 8px; }

    /* コントロール */
    .controls { display: grid; grid-template-columns: auto auto; gap: 8px 12px; align-items: center; }
    .controls select, .controls button { padding: 6px 8px; font-size: 14px; }
    .controls-row { display: grid; grid-template-columns: auto auto auto; gap: 8px 12px; align-items: center; margin-top: 8px; }
    #info { font-weight: 600; }

    /* 描画領域 */
    #map { width: 100%; border: 1px solid #ddd; border-radius: 10px; margin-top: 12px; }

    /* ラベル */
    .label text.name { font-size: 12px; dominant-baseline: central; }
    .label .line-pill { font-size: 11px; dominant-baseline: hanging; fill: #fff; }
    .pill-bg { rx: 6; ry: 6; }

    /* 駅 ● */
    .station.major circle.node { r: var(--major-r); fill: var(--line-color); stroke: var(--line-color); stroke-width: 3; }
    .station.minor circle.node { r: var(--minor-r); fill: #fff; stroke: var(--line-color); stroke-width: 2; }
    .station.minor text.name { font-size: 10px; fill: #333; dominant-baseline: central; }

    /* 区間線 */
    line.segment { stroke-width: var(--seg-width); stroke-linecap: round; }

    /* 途中駅トグルボタン */
    .seg-btn { font-size: 12px; padding: 2px 6px; margin-left: 8px; }
  </style>
</head>
<body>
  <h1>新里鉄道路線 ルート検索</h1>
  <div class="controls">
    <label>出発路線：<select id="fromLine"></select></label>
    <label>出発駅：<select id="fromStation"></select></label>
    <label>到着路線：<select id="toLine"></select></label>
    <label>到着駅：<select id="toStation"></select></label>
  </div>
  <div class="controls-row">
    <button id="searchBtn">経路検索</button>
    <span id="info"></span>
  </div>

  <svg id="map" height="400"></svg>

  <script>
    // ==== 駅・路線データ（変更不可・そのまま使用）====
    const stationLines = { "湯の浜線":["豊町","東豊町","清水浜","安田町","南栃原","栃原","宇城","須川","御浜埼公園","御浜","伊坂","垳下","北浜","西新里","新里","河岸","新里海浜公園","湯の浜海岸","湯の浜","七浦","那珂町","宇多野","伊奈崎","鶴宮神社","鶴宮","北鶴宮"], "燠野線":["湯の浜","新里大学前","綾原","福来","燠野","湯川","温泉口","燠野温泉"], "鶴宮線":["鶴宮","南鶴宮","あずさ台","橘町","燠野山口","白枝","燠野","紅葉台","桐山","湊川","彩山親水公園","彩山","蓮華寺","星宮","田ノ原"], "新里線":["新里","南新里","田ノ原","北玖川","玖川","中野原"], "彩山線":["彩山","彩山口","新里国際スキー場","鷹見台","久我原","浪原","深江","三栗谷","桜川公園","桜川"] };
    const lineColors = { "湯の浜線":"#07b5f7", "燠野線":"#fd5062", "新里線":"#0cab5e", "鶴宮線":"#feac2c", "彩山線":"#7dca22" };

    // ==== 駅間距離データ（双方向展開）====
    const rawGraph = { "豊町":{"東豊町":1.2}, "東豊町":{"清水浜":1.4}, "清水浜":{"安田町":1.9}, "安田町":{"南栃原":2.2}, "南栃原":{"栃原":0.9}, "栃原":{"宇城":2.2}, "宇城":{"須川":2.1}, "須川":{"御浜埼公園":1.9}, "御浜埼公園":{"御浜":0.6}, "御浜":{"伊坂":2.5}, "伊坂":{"垳下":2.6}, "垳下":{"北浜":2.3}, "北浜":{"西新里":1.4}, "西新里":{"新里":1.7}, "新里":{"河岸":0.9,"南新里":2.5}, "河岸":{"新里海浜公園":1.7}, "新里海浜公園":{"湯の浜海岸":2.3}, "湯の浜海岸":{"湯の浜":1.5}, "湯の浜":{"七浦":2.5,"新里大学前":0.8}, "七浦":{"那珂町":1.6}, "那珂町":{"宇多野":2.2}, "宇多野":{"伊奈崎":1.8}, "伊奈崎":{"鶴宮神社":1.5}, "鶴宮神社":{"鶴宮":1.2}, "鶴宮":{"北鶴宮":1.1,"南鶴宮":1.7}, "新里大学前":{"綾原":0.7}, "綾原":{"福来":1.2}, "福来":{"燠野":1.4}, "燠野":{"湯川":2.6,"紅葉台":1.1}, "湯川":{"温泉口":1.6}, "温泉口":{"燠野温泉":1.9}, "南鶴宮":{"あずさ台":1.4}, "あずさ台":{"橘町":1.8}, "橘町":{"燠野山口":1.1}, "燠野山口":{"白枝":1.2}, "白枝":{"燠野":1.1}, "紅葉台":{"桐山":0.8}, "桐山":{"湊川":0.8}, "湊川":{"彩山親水公園":1.1}, "彩山親水公園":{"彩山":1.2}, "彩山":{"蓮華寺":0.8,"彩山口":2.1}, "蓮華寺":{"星宮":1.1}, "星宮":{"田ノ原":1.1}, "南新里":{"田ノ原":2.3}, "田ノ原":{"北玖川":2.4}, "北玖川":{"玖川":3.1}, "玖川":{"中野原":3.1}, "彩山口":{"新里国際スキー場":3.4}, "新里国際スキー場":{"鷹見台":10.7}, "鷹見台":{"久我原":2.7}, "久我原":{"浪原":1.5}, "浪原":{"深江":1.4}, "深江":{"三栗谷":1.3}, "三栗谷":{"桜川公園":1.5}, "桜川公園":{"桜川":2.2} };
    const graph = {}; // 双方向
    for (const [from, targets] of Object.entries(rawGraph)) {
      if (!graph[from]) graph[from] = {};
      for (const [to, d] of Object.entries(targets)) {
        graph[from][to] = d;
        if (!graph[to]) graph[to] = {};
        graph[to][from] = d;
      }
    }

    // ==== 運賃（参照前に定義）====
    function fare(distance){
      if(distance<=3) return {adult:130,child:70};
      else if(distance<=6) return {adult:160,child:80};
      else if(distance<=10) return {adult:190,child:100};
      else if(distance<=15) return {adult:220,child:110};
      else if(distance<=20) return {adult:250,child:130};
      else if(distance<=25) return {adult:280,child:140};
      else if(distance<=30) return {adult:310,child:160};
      else return {adult:340,child:170};
    }

    // ==== UI初期化（路線→駅）====
    const fromLineSel = document.getElementById('fromLine');
    const toLineSel   = document.getElementById('toLine');
    const fromStaSel  = document.getElementById('fromStation');
    const toStaSel    = document.getElementById('toStation');

    function populateLineSelect(sel){ sel.innerHTML=''; Object.keys(stationLines).forEach(l=> sel.add(new Option(l,l))); sel.selectedIndex=0; }
    function populateStationSelect(lineSel, staSel){ staSel.innerHTML=''; (stationLines[lineSel.value]||[]).forEach(s=> staSel.add(new Option(s,s))); staSel.selectedIndex=0; }

    populateLineSelect(fromLineSel); populateStationSelect(fromLineSel, fromStaSel);
    populateLineSelect(toLineSel);   populateStationSelect(toLineSel, toStaSel);

    fromLineSel.addEventListener('change',()=>populateStationSelect(fromLineSel, fromStaSel));
    toLineSel.addEventListener('change',  ()=>populateStationSelect(toLineSel,   toStaSel));

    // ==== 経路探索（ダイクストラ）====
    function shortestPath(start, goal){
      const dist={}, prev={};
      const Q=new Set(Object.keys(graph));
      Object.keys(graph).forEach(s=>dist[s]=Infinity);
      dist[start]=0;
      while(Q.size){
        let u=null, best=Infinity; for(const n of Q){ if(dist[n]<best){best=dist[n]; u=n;} }
        if(u===null) break; Q.delete(u);
        if(u===goal) break;
        for(const [v,w] of Object.entries(graph[u]||{})){
          const alt=dist[u]+w; if(alt<dist[v]){ dist[v]=alt; prev[v]=u; }
        }
      }
      const path=[]; let u=goal; while(u){ path.unshift(u); u=prev[u]; }
      return { path, distance: dist[goal] };
    }

    // ==== 区間の路線名（ majors[i]→majors[i+1] に使う路線）====
    function segmentLineBetween(fullPath, a, b){
      const i1 = fullPath.indexOf(a);
      const i2 = fullPath.indexOf(b);
      for(let i=i1; i<i2; i++){
        const ln = findAdjacentLine(fullPath[i], fullPath[i+1]);
        if(ln) return ln;
      }
      return null;
    }

    // 隣接2駅が同一路線の隣同士ならその路線名
    function findAdjacentLine(a,b){
      for(const [line, arr] of Object.entries(stationLines)){
        const ia=arr.indexOf(a), ib=arr.indexOf(b);
        if(ia!==-1 && ib!==-1 && Math.abs(ia-ib)===1) return line;
      }
      return null;
    }

    // 主要駅（出発・乗換・到着）を抽出
    function extractMajorStations(path){
      if(path.length===0) return [];
      const majors=[path[0]];
      for(let i=1;i<path.length-1;i++){
        const l1=findAdjacentLine(path[i-1],path[i]);
        const l2=findAdjacentLine(path[i],path[i+1]);
        if(l1!==l2) majors.push(path[i]);
      }
      majors.push(path[path.length-1]);
      return majors;
    }

    // a→b 区間に含まれる途中駅（順方向）
    function intermediatesBetween(path, a, b){
      const i1 = path.indexOf(a);
      const i2 = path.indexOf(b);
      if(i1===-1 || i2===-1 || i2<=i1+1) return [];
      return path.slice(i1+1, i2);
    }

    // ==== 描画 ====
    const svg = document.getElementById('map');
    function clearSVG(){ while(svg.firstChild) svg.removeChild(svg.firstChild); }

    // トグル状態保持（区間ごと）
    const segToggle = new Map(); // key: "A→B" bool

    function drawRoute(path){
      clearSVG();
      if(!path || path.length<2) return;

      const majors = extractMajorStations(path);

      // 区間ごとの表示・高さを決める（非表示なら最小高、表示なら途中駅数に応じて可変）
      const top = 34; const minGap = 60; const basePad = 30; // 非表示時の最小ギャップ
      const segmentMeta = [];
      for(let i=0;i<majors.length-1;i++){
        const a = majors[i], b = majors[i+1];
        const subs = intermediatesBetween(path, a, b);
        const key = `${a}→${b}`;
        const show = !!segToggle.get(key);
        // 表示時は途中駅の数+1で均等割りするだけの高さを確保
        const gap = show ? Math.max(minGap, basePad + (subs.length+1)*28) : minGap;
        const lineName = segmentLineBetween(path, a, b);
        segmentMeta.push({a,b,subs,key,show,gap,lineName});
      }

      // 主要駅のYを累積で決定（非表示なら狭く、表示なら広く）
      const ys = [top];
      for(const seg of segmentMeta){ ys.push( ys[ys.length-1] + seg.gap ); }

      // SVG高さ調整
      svg.setAttribute('height', Math.max(220, ys[ys.length-1] + 40));

      const cx = 140; // ●のX（全て中央を揃える）
      const MAJOR_R = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--major-r')) || 10;

      for(let i=0;i<majors.length;i++){
        const st = majors[i];
        const cy = ys[i];
        const prevSt = i>0 ? majors[i-1] : null;
        const nextSt = i<majors.length-1 ? majors[i+1] : null;
        const metaPrev = i>0 ? segmentMeta[i-1] : null;
        const metaNext = i<segmentMeta.length ? segmentMeta[i] : null;
        const colorPrev = metaPrev ? (lineColors[metaPrev.lineName] || '#999') : null;

        // 上の主要駅からこの駅までの線
        if(prevSt){
          const y1 = ys[i-1] + MAJOR_R;
          const y2 = cy - MAJOR_R;
          const segL = document.createElementNS('http://www.w3.org/2000/svg','line');
          segL.setAttribute('class','segment');
          segL.setAttribute('x1', cx); segL.setAttribute('y1', y1);
          segL.setAttribute('x2', cx); segL.setAttribute('y2', y2);
          segL.setAttribute('stroke', colorPrev || '#999');
          svg.appendChild(segL);
        }

        // 主要駅 ●（路線カラーで塗る：下方向の区間色を優先、なければ上の色）
        const circleLine = metaNext ? metaNext.lineName : (metaPrev ? metaPrev.lineName : null);
        drawStation({name: st, x: cx, y: cy, isMajor: true, line: circleLine});

        // ラベル（駅名＋路線ピル）
        const label = document.createElementNS('http://www.w3.org/2000/svg','g');
        label.setAttribute('class','label');
        label.setAttribute('transform', `translate(${cx + 22}, ${cy})`);
        svg.appendChild(label);
        const nameText = document.createElementNS('http://www.w3.org/2000/svg','text');
        nameText.setAttribute('class','name');
        nameText.setAttribute('dominant-baseline','central');
        nameText.textContent = st;
        label.appendChild(nameText);

        // 路線名ピル（発駅・乗換駅のみ＝次があれば表示）
        if(nextSt && metaNext && metaNext.lineName){
          const color = lineColors[metaNext.lineName];
          const pillGroup = document.createElementNS('http://www.w3.org/2000/svg','g');
          pillGroup.setAttribute('transform', 'translate(0, 16)');
          label.appendChild(pillGroup);

          const text = document.createElementNS('http://www.w3.org/2000/svg','text');
          text.setAttribute('class','line-pill');
          const txt = `新里鉄道${metaNext.lineName}`;
          text.textContent = txt;
          pillGroup.appendChild(text);
          const bbox = text.getBBox();
          const bg = document.createElementNS('http://www.w3.org/2000/svg','rect');
          bg.setAttribute('class','pill-bg');
          bg.setAttribute('x', bbox.x - 6);
          bg.setAttribute('y', bbox.y - 2);
          bg.setAttribute('width', bbox.width + 12);
          bg.setAttribute('height', bbox.height + 6);
          bg.setAttribute('fill', color);
          pillGroup.insertBefore(bg, text);
        }

        // 途中駅トグル（発駅・乗換駅のみ=次の主要駅があるとき）
        if(metaNext){
          const btn = document.createElementNS('http://www.w3.org/2000/svg','foreignObject');
          btn.setAttribute('x', cx + 22 + 120);
          btn.setAttribute('y', cy - 12);
          btn.setAttribute('width', 120);
          btn.setAttribute('height', 24);
          const div = document.createElement('div');
          div.className = 'seg-btn';
          const key = metaNext.key;
          const on = !!segToggle.get(key);
          div.textContent = on ? '途中駅を非表示' : '途中駅を表示';
          div.style.cursor = 'pointer';
          div.style.background = '#f3f3f3';
          div.style.border = '1px solid #ccc';
          div.style.borderRadius = '6px';
          div.style.display = 'inline-block';
          div.style.padding = '2px 6px';
          div.addEventListener('click', ()=>{
            segToggle.set(key, !segToggle.get(key));
            drawRoute(path); // 再描画（非表示時は余白ゼロ）
          });
          btn.appendChild(div);
          svg.appendChild(btn);
        }

        // 途中駅（この主要駅から次の主要駅の間）
        if(metaNext && metaNext.show){
          const color = lineColors[metaNext.lineName] || '#999';
          const y1 = cy + MAJOR_R; // 下端
          const y2 = ys[i+1] - MAJOR_R; // 次の●の上端
          const subs = metaNext.subs;
          const step = (y2 - y1) / (subs.length + 1);
          subs.forEach((name, idx)=>{
            const sy = y1 + step*(idx+1);
            drawStation({name, x: cx, y: sy, isMajor:false, line: metaNext.lineName});
          });
        }
      }
    }

    function drawStation({name, x, y, isMajor, line}){
      const g = document.createElementNS('http://www.w3.org/2000/svg','g');
      g.setAttribute('class', `station ${isMajor? 'major':'minor'}`);
      g.setAttribute('transform', `translate(${x}, ${y})`);
      if(line){ g.style.setProperty('--line-color', lineColors[line] || '#999'); }

      const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
      c.setAttribute('class','node');
      c.setAttribute('cx', 0);
      c.setAttribute('cy', 0);
      g.appendChild(c);

      // 駅名（途中駅は●の右、主要駅は上で作成）
      if(!isMajor){
        const t = document.createElementNS('http://www.w3.org/2000/svg','text');
        t.setAttribute('class','name');
        t.setAttribute('x', 16);
        t.setAttribute('y', 0);
        t.setAttribute('dominant-baseline','central');
        t.textContent = name;
        g.appendChild(t);
      }
      svg.appendChild(g);
    }

    // ==== 検索実行 ====
    document.getElementById('searchBtn').addEventListener('click', ()=>{
      const from = fromStaSel.value; const to = toStaSel.value;
      if(!from || !to){ alert('駅を選択してください'); return; }
      if(from === to){ alert('発着駅が同一です。別の駅を選んでください。'); return; }

      const {path, distance} = shortestPath(from, to);
      if(!path || !isFinite(distance)) { alert('経路が見つかりませんでした'); return; }

      // 新しい検索では全区間の途中駅を非表示に初期化
      segToggle.clear();
      drawRoute(path);

      const f = fare(distance);
      document.getElementById('info').textContent = `距離 ${distance.toFixed(1)}km ／ 運賃 大人${f.adult}円 子供${f.child}円`;
    });

    // ========== 簡易テスト（コンソール） ==========
    (function selfTest(){
      try{
        console.assert(typeof fare === 'function', 'fare exists');
        console.assert(fare(2).adult===130 && fare(7).adult===190, 'fare tiers');
        const p = shortestPath('豊町','北鶴宮');
        console.assert(Array.isArray(p.path) && p.path.length>1, 'shortest path');
        const majors = extractMajorStations(p.path);
        if(majors.length>=2){
          const subs = intermediatesBetween(p.path, majors[0], majors[1]);
          const i1=p.path.indexOf(majors[0]), i2=p.path.indexOf(majors[1]);
          console.assert(subs.join(',')===p.path.slice(i1+1,i2).join(','),'subs forward order');
        }
        console.log('[self-test] OK');
      }catch(e){ console.warn('[self-test] NG', e); }
    })();
  </script>
</body>
</html>
